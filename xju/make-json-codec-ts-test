#!/bin/env python3

# generated typescript for use by test-json-codec-typescript.ts

import json
import re
from typing import Literal, Self, NewType, ClassVar
from types import NoneType
from ipaddress import IPv4Address,IPv4Interface
from xju.json_codec import codec, TypeScriptNamespace, TypeScriptSourceCode, TypeScriptNamespace
from xju.json_codec import TypeScriptUQN, AnyJsonCodecImpl, encode_attr_as, PythonAttrName, JsonAttrName
from xju.json_codec import JsonType, dont_encode_attr
from xju.json_codec import CustomNonStringKeyClassCodec,CustomClassCodec,CustomStringKeyClassCodec
from xju.misc import ByteCount
from xju.newtype import Str, Float
from xju.time import Duration, Timestamp
from xju.assert_ import Assert
from xju.xn import readable_repr
from dataclasses import dataclass
from enum import Enum

namespace=TypeScriptNamespace({})

def indent(n: int, s:TypeScriptSourceCode)->str:
    lines=s.splitlines()
    return '\n'.join([lines[0].value()]+[(' '*n)+l.value() for l in lines[1:]])

ten_codec=codec(dict[Literal[10]|Literal[True],int])

class SurnameTag:pass
class Surname(Str[SurnameTag]):
    pattern=re.compile(r'^\S*$')  # disallow whitespace
    pass

surname_codec=codec(Surname)
surname_codec.ensure_typescript_defs(namespace)

class O(Enum):
    a='fred'
    b='jock'
    pass
o_codec=codec(O)
o_codec.ensure_typescript_defs(namespace)

@dataclass
class FullName:
    first_name: str
    middle_names: list[str]
    last_name: str
    _class: Literal["Upper", "Middle", "Lower"]
    pass

encode_attr_as(FullName, PythonAttrName("_class"), JsonAttrName("class"))

codec(FullName).ensure_typescript_defs(namespace)

@dataclass
class Prefs:
    colours: set[str]
    blinds: frozenset[str]
    pass

codec(Prefs).ensure_typescript_defs(namespace)

class MetresTag: pass

class Metres(Float[MetresTag]):
    pass
    
metres_codec=codec(Metres)
metres_codec.ensure_typescript_defs(namespace)

class NonStringKey:
    values: dict[TypeScriptUQN, int]
    pass

codec(NonStringKey).ensure_typescript_defs(namespace)

# ... custom class encoding by implementing CustomClassCodec protocol, for example
# to support encoding of external types with control over their json representation
# ... to be usable as a dictionary key, the class also has to implement either
# the CustomStringKeyClassCodec or CustomNonStringKeyClassCodec
class IpV4Addr(IPv4Address):
    __xju_json_codec=codec(int)

    # xju.json_codec.CustomClassCodec:
    @staticmethod
    def xju_json_codec_encode(x:object) -> JsonType:
        assert isinstance(x,IpV4Addr)
        return IpV4Addr.__xju_json_codec.encode(int(x))
    @staticmethod
    def xju_json_codec_decode(x:JsonType) -> object:
        return IpV4Addr(IpV4Addr.__xju_json_codec.decode(x))
    @staticmethod
    def xju_json_codec_get_json_schema(definitions:dict[str,dict]) -> dict:
        '''return json schema for T'''
        '''- may add any supporting definitions to definitions'''
        return IpV4Addr.__xju_json_codec.get_json_schema()
    @staticmethod
    def xju_json_codec_get_typescript_type() -> TypeScriptSourceCode:
        return TypeScriptSourceCode('number /* IpV4Addr */')
    @staticmethod
    def xju_json_codec_5_get_typescript_isa(
            expression:TypeScriptSourceCode,
            namespace: TypeScriptNamespace) -> TypeScriptSourceCode:
        '''return typescript source code that turns {expression} into a
            false - indicating expression is not a T
            xju.ts.ApplyDefaults - expression is a T
           - may add any supporting definitions to namespace, e.g. type for T itself'''
        return (TypeScriptSourceCode(f"// is a IpV4Addr?\n") +
                # note codec(int).get_typescript_isa here will apply
                # defaults, which is not "correct", but we know it
                # will never actually have any defaults to apply
                IpV4Addr.__xju_json_codec.get_typescript_isa(expression,namespace)+
                TypeScriptSourceCode(" && {applyDefaults: ():true=>true}"))
    @staticmethod
    def xju_json_codec_5_get_typescript_asa(
            expression:TypeScriptSourceCode,
            namespace: TypeScriptNamespace) -> TypeScriptSourceCode:
        '''return typescript source code that verifies {expression} with defaults applied would be a T and returns xju.ts.ApplyDefaults that would apply defaults, throwing an Error if {expression} is not valid as a T'''
        '''- may add any supporting definitions to namespace, e.g. type for T itself'''
        return IpV4Addr.__xju_json_codec.get_typescript_asa(expression,namespace) + TypeScriptSourceCode(" && {applyDefaults: ():true=>true }")

    # xju.json_codec.CustomNonStringKeyClassCodec:
    @staticmethod
    def xju_json_codec_get_object_key_json_schema(definitions:dict[str,dict]) -> dict:
        '''return json schema for T when used as an object key
           - may add any supporting definitions to definitions'''
        return {
            'description': "stringified-int IpV4Addr",
            'type': 'string',
            'pattern': r'^(0|[1-9][0-9]*)$'
        }

    @staticmethod
    def xju_json_codec_typescript_key_type()->Literal['NonString']:
        return 'NonString'
    
    @staticmethod
    def xju_json_codec_get_typescript_isa_key(
            expression:TypeScriptSourceCode,
            namespace: TypeScriptNamespace) -> TypeScriptSourceCode:
        '''return typescript source code that turns {expression} into a bool indicating whether the expression is a T-as-object-key'''
        '''- may add any supporting definitions to namespace, e.g. type for T itself'''
        # REVISIT: should validate the int value 0<=v<2^32
        return IpV4Addr.__xju_json_codec.get_typescript_isa_key(expression,namespace)
    @staticmethod
    def xju_json_codec_get_typescript_asa_key(
            expression:TypeScriptSourceCode,
            namespace: TypeScriptNamespace) -> TypeScriptSourceCode:
        '''return typescript source code that safely casts {expression} to a T, throwing an Error if {expression} is not valid as a T-as-object-key'''
        '''- may add any supporting definitions to namespace, e.g. type for T itself'''
        # REVISIT: should validate the int value 0<=v<2^32
        return IpV4Addr.__xju_json_codec.get_typescript_asa_key(expression,namespace)
    pass

Assert(IpV4Addr).isSubclassOf(CustomClassCodec)
Assert(IpV4Addr).isSubclassOf(CustomNonStringKeyClassCodec)

@dataclass
class IpV4AddrWithPrefix(IPv4Interface):
    """An IP host address in a network, e.g. 10.1.1.49/24"""
    if_str: str
    __codec=codec(str)
    def __post_init__(self):
        super().__init__(self.if_str)
        pass
    def __hash__(self):
        return hash((self.if_str, super().__hash__()))
    @staticmethod
    def xju_json_codec_decode(x:JsonType) -> object:
        return IpV4AddrWithPrefix(IpV4AddrWithPrefix.__codec.decode(x))
    @staticmethod
    def xju_json_codec_encode(x:object) -> JsonType:
        assert isinstance(x,IpV4AddrWithPrefix)
        return IpV4AddrWithPrefix.__codec.encode(x.if_str)
    @staticmethod
    def xju_json_codec_get_json_schema(definitions:dict[str,dict]) -> dict:
        '''return json schema for T'''
        '''- may add any supporting definitions to definitions'''
        return IpV4AddrWithPrefix.__codec.get_json_schema()
    @staticmethod
    def xju_json_codec_get_typescript_type() -> TypeScriptSourceCode:
        return TypeScriptSourceCode('string /* IpV4AddrWithPrefix */')
    @staticmethod
    def xju_json_codec_5_get_typescript_isa(
            expression:TypeScriptSourceCode,
            namespace: TypeScriptNamespace) -> TypeScriptSourceCode:
        '''return typescript source code that turns {expression} into a
            false - indicating expression is not a T
            xju.ts.ApplyDefaults - expression is a T
           - may add any supporting definitions to namespace, e.g. type for T itself'''
        return (TypeScriptSourceCode(f"// is a IpV4AddrWithPrefix?\n")+
                IpV4AddrWithPrefix.__codec.get_typescript_isa(expression,namespace)+
                TypeScriptSourceCode(" && {applyDefaults: ():true=>true}"))
    @staticmethod
    def xju_json_codec_5_get_typescript_asa(
            expression:TypeScriptSourceCode,
            namespace: TypeScriptNamespace) -> TypeScriptSourceCode:
        '''return typescript source code that verifies {expression} with defaults applied would be a T and returns xju.ts.ApplyDefaults that would apply defaults, throwing an Error if {expression} is not valid as a T'''
        '''- may add any supporting definitions to namespace, e.g. type for T itself'''
        # __codec.get_typescript_asa strictly applies defaults but
        # we know in this case that does nothing so we can use it here
        return IpV4AddrWithPrefix.__codec.get_typescript_asa(expression,namespace) + TypeScriptSourceCode(" && {applyDefaults: ():true=>true }")

    # xju.json_codec.CustomStringKeyClassCodec:
    @staticmethod
    def xju_json_codec_get_object_key_json_schema(definitions:dict[str,dict]) -> dict:
        '''return json schema for T when used as an object key
           - may add any supporting definitions to definitions'''
        return IpV4AddrWithPrefix.xju_json_codec_get_json_schema(definitions)
    @staticmethod
    def xju_json_codec_typescript_key_type()->Literal['String']:
        return 'String'
    @staticmethod
    def xju_json_codec_get_typescript_isa_key(
            expression:TypeScriptSourceCode,
            namespace: TypeScriptNamespace) -> TypeScriptSourceCode:
        '''return typescript source code that turns {expression} into a bool indicating whether the expression is a T-as-object-key'''
        '''- may add any supporting definitions to namespace, e.g. type for T itself'''
        # REVISIT: tighten to use regex and test
        return IpV4AddrWithPrefix.__codec.get_typescript_isa_key(expression,namespace)
    @staticmethod
    def xju_json_codec_get_typescript_asa_key(
            expression:TypeScriptSourceCode,
            namespace: TypeScriptNamespace) -> TypeScriptSourceCode:
        '''return typescript source code that safely casts {expression} to a T, throwing an Error if {expression} is not valid as a T-as-object-key'''
        '''- may add any supporting definitions to namespace, e.g. type for T itself'''
        # REVISIT: tighten to use regex and test
        return IpV4AddrWithPrefix.__codec.get_typescript_asa(expression,namespace)
    pass

Assert(IpV4AddrWithPrefix).isSubclassOf(CustomClassCodec)
Assert(IpV4AddrWithPrefix).isSubclassOf(CustomStringKeyClassCodec)


Colour = NewType('Colour',str)
codec(Colour).ensure_typescript_defs(namespace)

Milligrams = NewType('Milligrams',float)
codec(Milligrams).ensure_typescript_defs(namespace)

Votes = NewType('Votes',int)
codec(Votes).ensure_typescript_defs(namespace)

Enabled = NewType('Enabled',bool)
codec(Enabled).ensure_typescript_defs(namespace)
    
@dataclass
class Selfish:
    value: int
    next: dict[int, Self]
    pass

codec(Selfish).ensure_typescript_defs(namespace)

@dataclass
class Liasee:
    x: int
    pass

Lias=Liasee

@dataclass
class Liaser:
    l: Lias
    pass


codec(Lias).add_typescript_alias(namespace, [TypeScriptUQN('Lias')])
codec(Liaser).ensure_typescript_defs(namespace)

@dataclass
class DontEncode:
    y: str
    cl: int = 3
    pass

dont_encode_attr(DontEncode, PythonAttrName("cl"))
codec(DontEncode).ensure_typescript_defs(namespace)

# recursive types
from typing import Union
@dataclass
class And:
    a: tuple["B", "B", list["B"]]
    pass

@dataclass
class Or:
    o: tuple["B", "B", list["B"]]
    pass

B = Union[str, And, Or]

codec(B).add_typescript_alias(namespace, [TypeScriptUQN('B')])
codec(And).ensure_typescript_defs(namespace)
codec(Or).ensure_typescript_defs(namespace)

@dataclass(init=False)
class MixedEnumValue:
    def __init__(self, *args, **argv):
        match len(args):
            case 0:
                self.k = argv['k']
                self.v = argv['v']
            case 1:
                self.k, self.v = args[0].k, args[0].v
            case _:
                self.k, self.v = args

    k: int
    v: str

class MixedEnum(MixedEnumValue, Enum):
    a = MixedEnumValue(1, 'fred')
    b = MixedEnumValue(2, 'jock')
    pass

@dataclass
class EncodableData:
    an_int: int
    a_float: float
    a_str: str
    a_new_int: Votes
    an_xju_int: ByteCount
    a_new_float: Milligrams
    an_xju_float: Metres
    a_new_str: Colour
    a_null: None
    a_boolean: bool
    a_union: FullName | Surname | None
    a_list: list[int]
    any_list: list
    a_set: set[int]
    any_set: set
    a_frozen_set: frozenset[int]
    any_frozen_set: frozenset
    some_bytes: bytes
    a_tuple: tuple[int, str]
    a_literal_str: Literal['ann','mai']
    a_literal_int: Literal[7]
    a_literal_bool: Literal[True]
    a_class:FullName
    a_dont_encode:DontEncode
    fred_7_false:Literal['fred', 7, False]
    a_recurse_self:TypeScriptNamespace
    a_timestamp: Timestamp
    an_enum:O
    a_mixed_in_enum: MixedEnum
    a_recursive: B
    an_enum_value: Literal[O.a]

    a_custom_encoded: IpV4Addr
    another_custom_encoded: IpV4AddrWithPrefix

    # dictionary key encodings (json object keys must be strings; various python
    # dict key types are supported and encoded to/from strings)

    cl: ClassVar[int] = 3

encodableData_codec=codec(EncodableData)
encodableData_codec.ensure_typescript_defs(namespace)
codec(int|str).add_typescript_alias(namespace, [TypeScriptUQN('xju'),TypeScriptUQN('NorS')])


@dataclass
class EncodableKeyTypes:
    str_key: dict[str,int]
    int_key: dict[int,int]
    more_keys: dict[None|ByteCount|float|bool,int]
    duration_key: dict[Duration,int]
    timestamp_key: dict[Timestamp,int]
    non_str_literal_key: dict[Literal[10]|Literal[True],int]
    str_literal_key: dict[Literal["a\n\"nail\"'s tip"]|Literal[O.a]|Surname,int]
    enum_key: dict[O,int]
    custom_key: dict[IpV4Addr,int]
    alt_custom_key: dict[IpV4AddrWithPrefix,int]
    newstr_key: dict[Colour,int]
    newfloat_key: dict[Milligrams,int]
    newint_key: dict[Votes,int]
    newbool_key: dict[Enabled,int]
    any_key: dict
    pass

encodable_key_types_codec=codec(EncodableKeyTypes)
encodable_key_types_codec.ensure_typescript_defs(namespace)

print(namespace.get_formatted_defs('export '))

try:
    codec(int|str).add_typescript_alias(namespace, [TypeScriptUQN('xju'),TypeScriptUQN('NorS')])
except Exception as e:
    Assert(readable_repr(e)).contains('is already defined')
else:
    assert False
    pass

Assert(codec(int).typescript_as_object_key_type())==TypeScriptSourceCode("string /* int */")
Assert(codec(float).typescript_as_object_key_type())==TypeScriptSourceCode("string /* float */")
Assert(codec(bool).typescript_as_object_key_type())==TypeScriptSourceCode("string /* bool */")
Assert(codec(NoneType).typescript_as_object_key_type())==TypeScriptSourceCode("string /* null */")

try:
    codec(list[int]).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='Array<number> is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(list).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='Array<any> is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(set[int]).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='Array<number> /* with unique elements */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(set).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='Array<any> /* with unique elements */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(frozenset[int]).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='Array<number> /* with unique elements */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(frozenset).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='Array<any> /* with unique elements */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(tuple[bool]).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='[boolean] is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(dict).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='{ [key: string]: any } is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(dict[str,str]).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='{ [key: string]: string } is not allowed as a typescript object key type'
else:
    assert False
    pass

Assert(codec(ByteCount).typescript_as_object_key_type())==TypeScriptSourceCode('string /* xju.misc.ByteCount */')
Assert(codec(Duration).typescript_as_object_key_type())==TypeScriptSourceCode('string /* xju.time.Duration */')

Assert(codec(Timestamp).typescript_as_object_key_type())==TypeScriptSourceCode(
    "string /* xju.time.Timestamp */")

try:
    codec(NonStringKey).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='NonStringKey is not allowed as a typescript object key type'
else:
    assert False
    pass

Assert(codec(O).typescript_as_object_key_type())==TypeScriptSourceCode("string /* O */")

try:
    AnyJsonCodecImpl().typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='any is not allowed as a typescript object key type'
else:
    assert False
    pass
    
try:
    codec(FullName).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='FullName is not allowed as a typescript object key type'
else:
    assert False
    pass
    
try:
    codec(bytes).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='Array<number> /* bytes */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(Selfish).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='Selfish is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(Selfish).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Selfish is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(Selfish).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Selfish is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(list[int]).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Array<number> is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(list).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Array<any> is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(set[str]).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Array<string> /* with unique elements */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(set).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Array<any> /* with unique elements */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(frozenset[str]).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Array<string> /* with unique elements */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(frozenset).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Array<any> /* with unique elements */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(tuple[int,str]).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='[number,string] is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(tuple[int,str]).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='[number,string] is not allowed as a typescript object key type'
else:
    assert False
    pass

Assert(codec(dict[ByteCount,str]).decode({'38':'fred'}))=={ByteCount(38):'fred'}
Assert(codec(dict[ByteCount,str]).decode({38:'fred'}))=={ByteCount(38):'fred'}
Assert(codec(dict[ByteCount,str]).encode({ByteCount(38):'fred'}))=={38:'fred'}

Assert(codec(dict[bool|ByteCount,str]).decode({'38':'fred'}))=={ByteCount(38):'fred'}
Assert(codec(dict[bool|ByteCount,str]).decode({38:'fred'}))=={ByteCount(38):'fred'}
Assert(codec(dict[bool|ByteCount,str]).encode({ByteCount(38):'fred'}))=={38:'fred'}
Assert(codec(dict[bool|ByteCount,str]).decode({'true':'fred'}))=={True:'fred'}
Assert(codec(dict[bool|ByteCount,str]).decode({True:'fred'}))=={True:'fred'}
Assert(codec(dict[bool|ByteCount,str]).encode({True:'fred'}))=={True:'fred'}

Assert(codec(dict[Surname|str,str]).decode({'Jones':'fred'}))=={Surname('Jones'):'fred'}
Assert(codec(dict[Surname|str,str]).decode({'Mc Sweeney':'fred'}))=={'Mc Sweeney':'fred'}
Assert(codec(dict[Surname|str,str]).encode({Surname('Jones'):'fred'}))=={'Jones':'fred'}

Assert(codec(dict[Surname,str]).decode({'Jones':'fred'}))=={Surname('Jones'):'fred'}
Assert(codec(dict[Surname,str]).encode({Surname('Jones'):'fred'}))=={'Jones':'fred'}

c=codec(dict[int|bool,float])
try:
    c.decode({'fred':8.2})
except Exception as e:
    Assert(readable_repr(e))=="Failed to decode {'fred': 8.2} to a dict[int | bool, float] because\n- failed to decode key 'fred' via json.loads because\n  Expecting value: line 1 column 1 (char 0); and\n- failed to decode key 'fred' directly because\n  failed to decode 'fred' as one of (<class 'int'>, <class 'bool'>) because\n  - failed to decode as <class 'int'> because\n    'fred' (of type <class 'str'>) is not a <class 'int'>; and\n  - failed to decode as <class 'bool'> because\n    'fred' (of type <class 'str'>) is not a <class 'bool'>."
else:
    assert False
    pass

try:
    codec(dict[dict[int,bool],str]).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=='{ [key: string /* int */]: boolean } is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(dict[dict,str]).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=='{ [key: string]: any } is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(dict[JsonType,str]).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=="Failed to get typescript type of dictionary key that is any of (<class 'NoneType'>, <class 'bool'>, <class 'dict'>, <class 'list'>, <class 'float'>, <class 'str'>) because\n{ [key: string]: any } is not allowed as a typescript object key type."
else:
    assert False
    pass

try:
    codec(bytes).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=='Array<number> /* bytes */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(dict).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=='{ [key: string]: any } is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(JsonType).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=='{ [key: string]: any } is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(list[int]).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Array<number> is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(list).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Array<any> is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(set[str]).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Array<string> /* with unique elements */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(set).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Array<any> /* with unique elements */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(frozenset[str]).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Array<string> /* with unique elements */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(frozenset).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Array<any> /* with unique elements */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(tuple[int,str]).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='[number,string] is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(tuple[int,str]).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='[number,string] is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(dict[dict[int,bool],str]).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=='{ [key: string /* int */]: boolean } is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(dict[dict,str]).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=='{ [key: string]: any } is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    AnyJsonCodecImpl().get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='any is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(bytes).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=='Array<number> /* bytes */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(dict).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=='{ [key: string]: any } is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    AnyJsonCodecImpl().get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='any is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(FullName).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=='FullName is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(FullName).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=='FullName is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(dict[list[int],str]).get_json_schema()  # type: ignore # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e)).contains("list is not allowed as json object key type")
else:
    assert False
    pass

try:
    codec(dict[list,str]).get_json_schema()  # type: ignore # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e)).contains("list is not allowed as json object key type")
else:
    assert False
    pass

try:
    codec(dict[set[str],str]).get_json_schema()  # type: ignore # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e)).contains("set is not allowed as json object key type")
else:
    assert False
    pass

try:
    codec(dict[frozenset[str],str]).get_json_schema()  # type: ignore # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e)).contains("frozenset is not allowed as json object key type")
else:
    assert False
    pass

try:
    codec(dict[set,str]).get_json_schema()  # type: ignore # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e)).contains("set is not allowed as json object key type")
else:
    assert False
    pass

try:
    codec(dict[frozenset,str]).get_json_schema()  # type: ignore # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e)).contains("frozenset is not allowed as json object key type")
else:
    assert False
    pass

try:
    codec(dict[tuple[int,str],str]).get_json_schema()  # type: ignore # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e)).contains("tuple is not allowed as json object key type")
else:
    assert False
    pass

try:
    codec(dict[dict[int,str],str]).get_json_schema()  # type: ignore # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e)).contains("dict is not allowed as json object key type")
else:
    assert False
    pass

try:
    codec(dict[dict,str]).get_json_schema()  # type: ignore # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e)).contains("dict is not allowed as json object key type")
else:
    assert False
    pass

try:
    # unreachable via codec()
    AnyJsonCodecImpl().get_object_key_json_schema({})
except Exception as e:
    Assert(readable_repr(e)).contains("any json type is not allowed as json object key type")
else:
    assert False
    pass

try:
    codec(dict[bytes,str]).get_json_schema()  # type: ignore # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e)).contains("bytes is not allowed as json object key type")
else:
    assert False
    pass

try:
    codec(dict[FullName,str]).get_json_schema()  # type: ignore # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e)).contains("FullName is not allowed as json object key type")
else:
    assert False
    pass
