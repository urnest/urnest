#!/bin/env python3

import json
import re
from typing import Literal, Self, NewType, ClassVar
from types import NoneType
from ipaddress import IPv4Address,IPv4Interface
from xju.json_codec import codec, TypeScriptNamespace, TypeScriptSourceCode, TypeScriptNamespace
from xju.json_codec import TypeScriptUQN, AnyJsonCodecImpl, encode_attr_as, PythonAttrName, JsonAttrName
from xju.json_codec import JsonType, dont_encode_attr
from xju.json_codec import CustomNonStringKeyClassCodec,CustomClassCodec,CustomStringKeyClassCodec
from xju.misc import ByteCount
from xju.newtype import Str, Float
from xju.time import Duration, Timestamp
from xju.assert_ import Assert
from xju.xn import readable_repr
from dataclasses import dataclass
from enum import Enum

namespace=TypeScriptNamespace({})

def indent(n: int, s:TypeScriptSourceCode)->str:
    lines=s.splitlines()
    return '\n'.join([lines[0].value()]+[(' '*n)+l.value() for l in lines[1:]])

ten_codec=codec(dict[Literal[10]|Literal[True],int])

class SurnameTag:pass
class Surname(Str[SurnameTag]):
    pattern=re.compile(r'^\S*$')  # disallow whitespace
    pass

surname_codec=codec(Surname)
surname_codec.ensure_typescript_defs(namespace)

class O(Enum):
    a='fred'
    b='jock'
    pass
o_codec=codec(O)
o_codec.ensure_typescript_defs(namespace)

@dataclass
class FullName:
    first_name: str
    middle_names: list[str]
    last_name: str
    _class: Literal["Upper", "Middle", "Lower"]
    pass

encode_attr_as(FullName, PythonAttrName("_class"), JsonAttrName("class"))

codec(FullName).ensure_typescript_defs(namespace)

@dataclass
class Prefs:
    colours: set[str]
    blinds: frozenset[str]
    pass

codec(Prefs).ensure_typescript_defs(namespace)

class MetresTag: pass

class Metres(Float[MetresTag]):
    pass
    
metres_codec=codec(Metres)
metres_codec.ensure_typescript_defs(namespace)

class NonStringKey:
    values: dict[TypeScriptUQN, int]
    pass

codec(NonStringKey).ensure_typescript_defs(namespace)

# ... custom class encoding by implementing CustomClassCodec protocol, for example
# to support encoding of external types with control over their json representation
# ... to be usable as a dictionary key, the class also has to implement either
# the CustomStringKeyClassCodec or CustomNonStringKeyClassCodec
class IpV4Addr(IPv4Address):
    __xju_json_codec=codec(int)

    # xju.json_codec.CustomClassCodec:
    @staticmethod
    def xju_json_codec_encode(x:object) -> JsonType:
        assert isinstance(x,IpV4Addr)
        return IpV4Addr.__xju_json_codec.encode(int(x))
    @staticmethod
    def xju_json_codec_decode(x:JsonType) -> object:
        return IpV4Addr(IpV4Addr.__xju_json_codec.decode(x))
    @staticmethod
    def xju_json_codec_get_json_schema(definitions:dict[str,dict]) -> dict:
        '''return json schema for T'''
        '''- may add any supporting definitions to definitions'''
        return IpV4Addr.__xju_json_codec.get_json_schema()
    @staticmethod
    def xju_json_codec_get_typescript_type() -> TypeScriptSourceCode:
        return TypeScriptSourceCode('number /* IpV4Addr */')
    @staticmethod
    def xju_json_codec_5_get_typescript_isa(
            expression:TypeScriptSourceCode,
            namespace: TypeScriptNamespace) -> TypeScriptSourceCode:
        '''return typescript source code that turns {expression} into a
            false - indicating expression is not a T
            xju.ts.ApplyDefaults - expression is a T
           - may add any supporting definitions to namespace, e.g. type for T itself'''
        return (TypeScriptSourceCode(f"// is a IpV4Addr?\n") +
                # note codec(int).get_typescript_isa here will apply
                # defaults, which is not "correct", but we know it
                # will never actually have any defaults to apply
                IpV4Addr.__xju_json_codec.get_typescript_isa(expression,namespace)+
                TypeScriptSourceCode(" && {applyDefaults: ():true=>true}"))
    @staticmethod
    def xju_json_codec_5_get_typescript_asa(
            expression:TypeScriptSourceCode,
            namespace: TypeScriptNamespace) -> TypeScriptSourceCode:
        '''return typescript source code that verifies {expression} with defaults applied would be a T and returns xju.ts.ApplyDefaults that would apply defaults, throwing an Error if {expression} is not valid as a T'''
        '''- may add any supporting definitions to namespace, e.g. type for T itself'''
        return IpV4Addr.__xju_json_codec.get_typescript_asa(expression,namespace) + TypeScriptSourceCode(" && {applyDefaults: ():true=>true }")

    # xju.json_codec.CustomNonStringKeyClassCodec:
    @staticmethod
    def xju_json_codec_get_object_key_json_schema(definitions:dict[str,dict]) -> dict:
        '''return json schema for T when used as an object key
           - may add any supporting definitions to definitions'''
        return {
            'description': "stringified-int IpV4Addr",
            'type': 'string',
            'pattern': r'^(0|[1-9][0-9]*)$'
        }

    @staticmethod
    def xju_json_codec_typescript_key_type()->Literal['NonString']:
        return 'NonString'
    
    @staticmethod
    def xju_json_codec_get_typescript_isa_key(
            expression:TypeScriptSourceCode,
            namespace: TypeScriptNamespace) -> TypeScriptSourceCode:
        '''return typescript source code that turns {expression} into a bool indicating whether the expression is a T-as-object-key'''
        '''- may add any supporting definitions to namespace, e.g. type for T itself'''
        # REVISIT: should validate the int value 0<=v<2^32
        return IpV4Addr.__xju_json_codec.get_typescript_isa_key(expression,namespace)
    @staticmethod
    def xju_json_codec_get_typescript_asa_key(
            expression:TypeScriptSourceCode,
            namespace: TypeScriptNamespace) -> TypeScriptSourceCode:
        '''return typescript source code that safely casts {expression} to a T, throwing an Error if {expression} is not valid as a T-as-object-key'''
        '''- may add any supporting definitions to namespace, e.g. type for T itself'''
        # REVISIT: should validate the int value 0<=v<2^32
        return IpV4Addr.__xju_json_codec.get_typescript_asa_key(expression,namespace)
    pass

Assert(IpV4Addr).isSubclassOf(CustomClassCodec)
Assert(IpV4Addr).isSubclassOf(CustomNonStringKeyClassCodec)

@dataclass
class IpV4AddrWithPrefix(IPv4Interface):
    """An IP host address in a network, e.g. 10.1.1.49/24"""
    if_str: str
    __codec=codec(str)
    def __post_init__(self):
        super().__init__(self.if_str)
        pass
    def __hash__(self):
        return hash((self.if_str, super().__hash__()))
    @staticmethod
    def xju_json_codec_decode(x:JsonType) -> object:
        return IpV4AddrWithPrefix(IpV4AddrWithPrefix.__codec.decode(x))
    @staticmethod
    def xju_json_codec_encode(x:object) -> JsonType:
        assert isinstance(x,IpV4AddrWithPrefix)
        return IpV4AddrWithPrefix.__codec.encode(x.if_str)
    @staticmethod
    def xju_json_codec_get_json_schema(definitions:dict[str,dict]) -> dict:
        '''return json schema for T'''
        '''- may add any supporting definitions to definitions'''
        return IpV4AddrWithPrefix.__codec.get_json_schema()
    @staticmethod
    def xju_json_codec_get_typescript_type() -> TypeScriptSourceCode:
        return TypeScriptSourceCode('string /* IpV4AddrWithPrefix */')
    @staticmethod
    def xju_json_codec_5_get_typescript_isa(
            expression:TypeScriptSourceCode,
            namespace: TypeScriptNamespace) -> TypeScriptSourceCode:
        '''return typescript source code that turns {expression} into a
            false - indicating expression is not a T
            xju.ts.ApplyDefaults - expression is a T
           - may add any supporting definitions to namespace, e.g. type for T itself'''
        return (TypeScriptSourceCode(f"// is a IpV4AddrWithPrefix?\n")+
                IpV4AddrWithPrefix.__codec.get_typescript_isa(expression,namespace)+
                TypeScriptSourceCode(" && {applyDefaults: ():true=>true}"))
    @staticmethod
    def xju_json_codec_5_get_typescript_asa(
            expression:TypeScriptSourceCode,
            namespace: TypeScriptNamespace) -> TypeScriptSourceCode:
        '''return typescript source code that verifies {expression} with defaults applied would be a T and returns xju.ts.ApplyDefaults that would apply defaults, throwing an Error if {expression} is not valid as a T'''
        '''- may add any supporting definitions to namespace, e.g. type for T itself'''
        # __codec.get_typescript_asa strictly applies defaults but
        # we know in this case that does nothing so we can use it here
        return IpV4AddrWithPrefix.__codec.get_typescript_asa(expression,namespace) + TypeScriptSourceCode(" && {applyDefaults: ():true=>true }")

    # xju.json_codec.CustomStringKeyClassCodec:
    @staticmethod
    def xju_json_codec_get_object_key_json_schema(definitions:dict[str,dict]) -> dict:
        '''return json schema for T when used as an object key
           - may add any supporting definitions to definitions'''
        return IpV4AddrWithPrefix.xju_json_codec_get_json_schema(definitions)
    @staticmethod
    def xju_json_codec_typescript_key_type()->Literal['String']:
        return 'String'
    @staticmethod
    def xju_json_codec_get_typescript_isa_key(
            expression:TypeScriptSourceCode,
            namespace: TypeScriptNamespace) -> TypeScriptSourceCode:
        '''return typescript source code that turns {expression} into a bool indicating whether the expression is a T-as-object-key'''
        '''- may add any supporting definitions to namespace, e.g. type for T itself'''
        # REVISIT: tighten to use regex and test
        return IpV4AddrWithPrefix.__codec.get_typescript_isa_key(expression,namespace)
    @staticmethod
    def xju_json_codec_get_typescript_asa_key(
            expression:TypeScriptSourceCode,
            namespace: TypeScriptNamespace) -> TypeScriptSourceCode:
        '''return typescript source code that safely casts {expression} to a T, throwing an Error if {expression} is not valid as a T-as-object-key'''
        '''- may add any supporting definitions to namespace, e.g. type for T itself'''
        # REVISIT: tighten to use regex and test
        return IpV4AddrWithPrefix.__codec.get_typescript_asa(expression,namespace)
    pass

Assert(IpV4AddrWithPrefix).isSubclassOf(CustomClassCodec)
Assert(IpV4AddrWithPrefix).isSubclassOf(CustomStringKeyClassCodec)


Colour = NewType('Colour',str)
codec(Colour).ensure_typescript_defs(namespace)

Milligrams = NewType('Milligrams',float)
codec(Milligrams).ensure_typescript_defs(namespace)

Votes = NewType('Votes',int)
codec(Votes).ensure_typescript_defs(namespace)

Enabled = NewType('Enabled',bool)
codec(Enabled).ensure_typescript_defs(namespace)
    
@dataclass
class Selfish:
    value: int
    next: dict[int, Self]
    pass

codec(Selfish).ensure_typescript_defs(namespace)

@dataclass
class Liasee:
    x: int
    pass

Lias=Liasee

@dataclass
class Liaser:
    l: Lias
    pass


codec(Lias).add_typescript_alias(namespace, [TypeScriptUQN('Lias')])
codec(Liaser).ensure_typescript_defs(namespace)

@dataclass
class DontEncode:
    y: str
    cl: int = 3
    pass

dont_encode_attr(DontEncode, PythonAttrName("cl"))
codec(DontEncode).ensure_typescript_defs(namespace)

# recursive types
from typing import Union
@dataclass
class And:
    a: tuple["B", "B", list["B"]]
    pass

@dataclass
class Or:
    o: tuple["B", "B", list["B"]]
    pass

B = Union[str, And, Or]

codec(B).add_typescript_alias(namespace, [TypeScriptUQN('B')])
codec(And).ensure_typescript_defs(namespace)
codec(Or).ensure_typescript_defs(namespace)

@dataclass(init=False)
class MixedEnumValue:
    def __init__(self, *args, **argv):
        match len(args):
            case 0:
                self.k = argv['k']
                self.v = argv['v']
            case 1:
                self.k, self.v = args[0].k, args[0].v
            case _:
                self.k, self.v = args

    k: int
    v: str

class MixedEnum(MixedEnumValue, Enum):
    a = MixedEnumValue(1, 'fred')
    b = MixedEnumValue(2, 'jock')
    pass

@dataclass
class EncodableData:
    an_int: int
    a_float: float
    a_str: str
    a_new_int: Votes
    an_xju_int: ByteCount
    a_new_float: Milligrams
    an_xju_float: Metres
    a_new_str: Colour
    a_null: None
    a_boolean: bool
    a_union: FullName | Surname | None
    a_list: list[int]
    any_list: list
    a_set: set[int]
    any_set: set
    a_frozen_set: frozenset[int]
    any_frozen_set: frozenset
    some_bytes: bytes
    a_tuple: tuple[int, str]
    a_literal_str: Literal['ann','mai']
    a_literal_int: Literal[7]
    a_literal_bool: Literal[True]
    a_class:FullName
    a_dont_encode:DontEncode
    fred_7_false:Literal['fred', 7, False]
    a_recurse_self:TypeScriptNamespace
    a_timestamp: Timestamp
    an_enum:O
    a_mixed_in_enum: MixedEnum
    a_recursive: B
    an_enum_value: Literal[O.a]

    a_custom_encoded: IpV4Addr
    another_custom_encoded: IpV4AddrWithPrefix

    # dictionary key encodings (json object keys must be strings; various python
    # dict key types are supported and encoded to/from strings)

    cl: ClassVar[int] = 3

encodableData_codec=codec(EncodableData)
encodableData_codec.ensure_typescript_defs(namespace)
codec(int|str).add_typescript_alias(namespace, [TypeScriptUQN('xju'),TypeScriptUQN('NorS')])


@dataclass
class EncodableKeyTypes:
    str_key: dict[str,int]
    int_key: dict[int,int]
    more_keys: dict[None|ByteCount|float|bool,int]
    duration_key: dict[Duration,int]
    timestamp_key: dict[Timestamp,int]
    non_str_literal_key: dict[Literal[10]|Literal[True],int]
    str_literal_key: dict[Literal["a\n\"nail\"'s tip"]|Literal[O.a]|Surname,int]
    enum_key: dict[O,int]
    custom_key: dict[IpV4Addr,int]
    alt_custom_key: dict[IpV4AddrWithPrefix,int]
    newstr_key: dict[Colour,int]
    newfloat_key: dict[Milligrams,int]
    newint_key: dict[Votes,int]
    newbool_key: dict[Enabled,int]
    any_key: dict
    pass

encodable_key_types_codec=codec(EncodableKeyTypes)
encodable_key_types_codec.ensure_typescript_defs(namespace)

print(namespace.get_formatted_defs())

print('''\
function str(x:any):string { return `${x}`; }
function isObject(x:any):x is object { return x !== null && typeof(x) === 'object'; }
function assert_equal<T>(x:T, y:T){
    if (Array.isArray(x) && Array.isArray(y)){
        assert_arrays_equal<any>(x,y);
    }
    else if (isObject(x) && isObject(y)){
        assert_objects_equal(x,y);
    }
    else if (!(x===y)){
        throw new Error(`${format_(x)} != ${format_(y)}`);
    }
}
function assert_not_equal<T>(x:T, y:T){
    try{
        assert_equal(x,y);
    }
    catch(e){
        return;
    }
    throw new Error(`${format_(x)} == ${format_(y)}`);
}
function format_<T>(a:T): string {
    if (Array.isArray(a)) return format_array(a);
    if (isObject(a)) return format_object(a);
    return JSON.stringify(a);
}
function format_array<T>(a:Array<T>): string {
    if(a.length==0) return "[]";
    if(a.length==1) return `[${format_(a[0])}]`;
    var result=`${format_(a[0])}`;
    for(var i=1;i!=a.length;++i) result=result+`,${format_(a[i])}`;
    return `[${result}]`;
}
function format_object<T>(a:T): string {
    var result="{";
    for(const k in a) result=result+` ${k}:${format_(a[k])},`;
    return result+"}";
}

function assert_arrays_equal<T>(x:Array<T>, y:Array<T>){
    try{
        try{
            assert_equal(x.length, y.length);
        }
        catch(e:any){
            throw new Error(`arrays of different length because ${e}`);
        }
        var i;
        for(i=0; i!=x.length; ++i){
            try{
                assert_equal<T>(x[i],y[i]);
            }
            catch(e:any){
                throw new Error(`array element ${i} ${format_(x[i])} != ${format_(y[i])}`);
            }
        }
    }
    catch(e:any){
        throw new Error(`array ${format_(x)} != array ${format_(y)} because ${e}`);
    }
}
function assert_objects_equal(x:object, y:object){
    try{
        var xKeys=new Array<keyof object>();
        var yKeys=new Array<keyof object>();
        for(const k in x){if (x.hasOwnProperty(k)) xKeys.push(k as keyof object);}
        for(const k in y){if (y.hasOwnProperty(k)) yKeys.push(k as keyof object);}
        assert_arrays_equal(xKeys,yKeys);
        for(var i=0; i!=xKeys.length; ++i){
            const k = xKeys[i];
            try{
                assert_equal(x[k],y[k]);
            }
            catch(e){
                throw new Error(`property ${k} is not equal because ${e}`);
            }
        }
    }
    catch(e){
        throw new Error(`object ${format_(x)} != object ${format_(y)} because ${e}`);
    }
}
function assert_x_contains_y(x:string, y:string){
    if (x.indexOf(y)==-1){
        throw new Error(`"${x}" does not contain "${y}"`)
    }
}
function assert_true(x:boolean){
    if (!x){
        throw new Error(`"${x}" is false, expected true`);
    }
}
function assert_false(x:boolean){
    if (x){
        throw new Error(`"${x}" is true, expected false`);
    }
}
function assert_never_reached(){
   throw new Error(`should not be here`);
}
''')

encoded_encodableData=json.dumps(encodableData_codec.encode(EncodableData(
    an_int = 7,
    a_float = 9.2,
    a_str = 'fred',
    a_new_int = Votes(22),
    an_xju_int = ByteCount(88),
    a_new_float = Milligrams(2.2),
    an_xju_float = Metres(18.2),
    a_new_str = Colour('red'),
    a_null = None,
    a_boolean = True,
    a_union = Surname('walker'),
    a_list = [1,2,3],
    any_list = [1,None,'a'],
    a_set = {4,5,6},
    any_set = {None, 2},
    a_frozen_set = frozenset([7]),
    any_frozen_set = frozenset([2, 4.6]),  # note python reorders
    some_bytes = bytes([10,11,12]),
    a_tuple = (8, 'jock'),
    a_literal_str = 'mai',
    a_literal_int = 7,
    a_literal_bool=True,
    a_class=FullName(first_name="fran",middle_names=["jan"],last_name="lan",_class="Upper"),
    a_dont_encode=DontEncode(y='yyy'),
    fred_7_false=False,
    a_recurse_self=TypeScriptNamespace({}),
    a_timestamp=Timestamp(45000),
    an_enum=O.a,
    a_mixed_in_enum=MixedEnum.b,
    a_recursive=And(a=(Or(o=("1","2",[])), "3",[And(a=("4","6",[]))])),
    an_enum_value=O.a,
    a_custom_encoded=IpV4Addr("177.88.12.1"),
    another_custom_encoded=IpV4AddrWithPrefix("177.88.12.0/22")
)))

print('''
//encodableData
(() => {
    const good = () => ({
        an_int: 7,
        a_float: 9.2,
        a_str: 'fred',
        a_new_int: 22,
        an_xju_int: 88,
        a_new_float: 2.2,
        an_xju_float: 18.2,
        a_new_str: 'red',
        a_null: null,
        a_boolean: true,
        a_union: 'walker',
        a_list: [1,2,3],
        any_list: [1,null,'a'],
        a_set: [4,5,6],
        any_set: [null, 2],
        a_frozen_set: [7],
        any_frozen_set: [2, 4.6], // python reorders
        some_bytes: [10,11,12],
        a_tuple: [8, 'jock'] as [number, string],
        a_literal_str: 'mai',
        a_literal_int: 7,
        a_literal_bool: true,
        a_class: {first_name:"fran",middle_names:["jan"],last_name:"lan",class:"Upper"},
        a_dont_encode:{y:'yyy'},
        fred_7_false:false,
        a_recurse_self:{defs:{}},
        a_timestamp:45000,
        an_enum:'fred',
        a_mixed_in_enum:{k:2,v:'jock'},
        a_recursive:{"a": [{"o": ["1","2",[]]},"3", [{ "a": ["4","6",[]] }]]},
        an_enum_value:"fred",
        a_custom_encoded:2975337473,
        another_custom_encoded:"177.88.12.0/22"
    });
'''
f'''
    assert_equal(asInstanceOfEncodableData({encoded_encodableData}) as object, good());
    assert_equal(isInstanceOfEncodableData({encoded_encodableData}), true);
'''
'''
    const errors:Array<string> = [];
    try {
        asInstanceOfEncodableData({
            ...good(),
            an_int: 7.6
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'Error: { an_int:7.6, a_float:9.2, a_str:"fred", a_new_int:22, an_xju_int:88, a_new_float:2.2, an_xju_float:18.2, a_new_str:"red", a_null:null, a_boolean:true, a_union:"walker", a_list:[1,2,3], any_list:[1,null,"a"], a_set:[4,5,6], any_set:[null,2], a_frozen_set:[7], any_frozen_set:[2,4.6], some_bytes:[10,11,12], a_tuple:[8,"jock"], a_literal_str:"mai", a_literal_int:7, a_literal_bool:true, a_class:{ first_name:"fran", middle_names:["jan"], last_name:"lan", class:"Upper" }, a_dont_encode:{ y:"yyy" }, fred_7_false:false, a_recurse_self:{ defs:{ } }, a_timestamp:45000, an_enum:"fred", a_mixed_in_enum:{ k:2, v:"jock" }, a_recursive:{ a:[{ o:["1","2",[]] },"3",[{ a:["4","6",[]] }]] }, an_enum_value:"fred", a_custom_encoded:2975337473, another_custom_encoded:"177.88.12.0/22" }');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableData({
            ...good(),
            a_float: null
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'attribute a_float is invalid because Error: null is not a number it is a object');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableData({
            ...good(),
            a_str: 77
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'is not a EncodableData because Error: attribute a_str is invalid because Error: 77 is not a string it is a number');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableData({
            ...good(),
            a_new_int: []
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'is not a EncodableData because Error: attribute a_new_int is invalid because Error: [] is not a number it is a object');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableData({
            ...good(),
            an_xju_int: []
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'attribute an_xju_int is invalid because Error: [] is not a xju.misc.ByteCount i.e. a number, it is a object');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableData({
            ...good(),
            a_new_float: []
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'is not a EncodableData because Error: attribute a_new_float is invalid because Error: [] is not a number it is a object');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableData({
            ...good(),
            an_xju_float: []
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'attribute an_xju_float is invalid because Error: [] is not a Metres i.e. a number, it is a object');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableData({
            ...good(),
            a_new_str: { }
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'is not a EncodableData because Error: attribute a_new_str is invalid because Error: { } is not a string it is a object');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableData({
            ...good(),
            a_null: { }
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'is not a EncodableData because Error: attribute a_null is invalid because Error: { } is not null it is a object');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableData({
            ...good(),
            a_boolean: 99
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'is not a EncodableData because Error: attribute a_boolean is invalid because Error: 99 is not a boolean it is a number');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableData({
            ...good(),
            a_union: 99
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'is not a EncodableData because Error: attribute a_union is invalid because Error: 99 is not a FullName|Surname|null because Error: 99 is not a FullName because Error: 99 is not an object it is a number and 99 is not a Surname i.e. a string, it is a number and 99 is not null it is a number');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableData({
            ...good(),
            a_list: [null]
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'is not a EncodableData because Error: attribute a_list is invalid because Error: [null] is not a Array<number> because Error: item at index 0 is invalid because Error: null is not a number it is a object');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableData({
            ...good(),
            any_list: null
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'attribute any_list is invalid because Error: null is not an Array it is a object');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableData({
            ...good(),
            a_set: [null]
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'is not a EncodableData because Error: attribute a_set is invalid because Error: [null] is not a Array<number> /* with unique elements */ because Error: item at index 0 is invalid because Error: null is not a number it is a object');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableData({
            ...good(),
            any_set: { }
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'attribute any_set is invalid because Error: [object Object] is not an Array<any> /* with unique elements */ it is a object');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableData({
            ...good(),
            a_frozen_set: [null]
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'is not a EncodableData because Error: attribute a_frozen_set is invalid because Error: [null] is not a Array<number> /* with unique elements */ because Error: null is not a number it is a object');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableData({
            ...good(),
            a_frozen_set: [null]
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'attribute a_frozen_set is invalid because Error: [null] is not a Array<number> /* with unique elements */ because Error: null is not a number it is a object');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableData({
            ...good(),
            some_bytes: [3000]
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'is not a EncodableData because Error: attribute some_bytes is invalid because Error: 3000 at index 0 is not in range 0..255');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableData({
            ...good(),
            a_tuple: [3000,99]
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'is not a EncodableData because Error: attribute a_tuple is invalid because Error: [3000,99] is not a [number,string] because Error: 99 is not a string it is a number');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableData({
            ...good(),
            a_literal_str: "kai"
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'is not a EncodableData because Error: attribute a_literal_str is invalid because Error: "kai" is not a "ann"|"mai" because Error: the string "kai" is not the string "ann" and the string "kai" is not the string "mai"');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableData({
            ...good(),
            a_literal_int: 8
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'is not a EncodableData because Error: attribute a_literal_int is invalid because Error: the number 8 is not the number 7');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableData({
            ...good(),
            a_literal_bool: false
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'is not a EncodableData because Error: attribute a_literal_bool is invalid because Error: the boolean false is not true');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableData({
            ...good(),
            a_class: {first_name:8,middle_names:["jan"],last_name:"lan"}
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'attribute first_name is invalid because Error: 8 is not a string it is a number');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableData({
            ...good(),
            fred_7_false:'jan'
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'attribute fred_7_false is invalid because Error: "jan" is not a "fred"|7|false because Error: the string "jan" is not the string "fred" and the string "jan" is not the number 7 and the string "jan" is not false');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        const x = asInstanceOfEncodableData({
            ...good(),
            a_recurse_self:999
        });
        assert_not_equal(x,x);
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'a_recurse_self is invalid because Error: 999 is not a xju.json_codec.TypeScriptNamespace because Error: 999 is not an object it is a number');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableData({
            ...good(),
            a_timestamp:null
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'null is not a xju.time.Timestamp i.e. a number, it is a object');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableData({
            ...good(),
            an_enum:7
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'attribute an_enum is invalid because Error: 7 is not a O because Error: 7 != "fred" and 7 != "jock"');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableData({
            ...good(),
            a_mixed_in_enum:{k:2,v:'brad'}
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'attribute a_mixed_in_enum is invalid because Error: { k:2, v:"brad" } is not a MixedEnum because Error: object { k:2, v:"brad" } != object { k:1, v:"fred" } because Error: property k is not equal because Error: 2 != 1 and object { k:2, v:"brad" } != object { k:2, v:"jock" } because Error: property v is not equal because Error: "brad" != "jock"');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableData({
            ...good(),
            an_enum_value:"paul"
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'attribute an_enum_value is invalid because Error: "paul" != "fred"');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableData({
            ...good(),
            a_recursive:[]
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'attribute a_recursive is invalid because Error: [] is not a string|And|Or because Error: [] is not a string it is a object and [] is not a And because Error: [] is an array and [] is not a Or because Error: [] is an array');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    assert_equal(errors, []);
})();
''')


encoded_key_types=json.dumps(encodable_key_types_codec.encode(EncodableKeyTypes(
    str_key={'fred': 3},
    int_key={1: 4},
    more_keys={None: 1, ByteCount(9): 2, 5.5: 3, True: 4},
    duration_key={Duration(77.2): 1},
    timestamp_key={Timestamp(88.1): 1},
    non_str_literal_key={10: 1, True: 2},
    str_literal_key={"a\n\"nail\"'s tip": 3, O.a: 4, Surname("rooster"): 5},
    enum_key={O.a: 1, O.b: 2},
    custom_key={IpV4Addr("192.8.8.1"): 1},
    alt_custom_key={IpV4AddrWithPrefix("192.8.8.1/24"): 1},
    newstr_key={Colour("red"): 1, Colour("green"): 2},
    newfloat_key={Milligrams(22): 1},
    newint_key={Votes(7): 1},
    newbool_key={Enabled(False): 1},
    any_key={"8":1, "fred": 2, "null": 3, "7.6": 4, "true": 5})))


print('''
//EncodableKeyTypes
(() => {
    const good = () => ({
        str_key:{ fred:3 },
        int_key:{ 1:4 },
        more_keys:{ 9:2, null:1, 5.5:3, true:4 },
        duration_key:{ 77.2:1 },
        timestamp_key:{ 88.1:1 },
        non_str_literal_key:{ 10:1, true:2 },
        str_literal_key:{ "a\\n\\"nail\\"'s tip":3, fred:4, rooster:5 },
        enum_key:{ fred:1, jock:2 },
        custom_key:{ 3221751809:1 },
        alt_custom_key:{ "192.8.8.1/24":1 },
        newstr_key:{ red:1, green:2 },
        newfloat_key:{ 22:1 },
        newint_key:{ 7:1 },
        newbool_key:{ false:1 },
        any_key:{ 8:1, fred:2, null:3, 7.6:4, true:5 }
    });
'''
f'''
    assert_equal(asInstanceOfEncodableKeyTypes({encoded_key_types}) as object, good());
    assert_equal(isInstanceOfEncodableData({encoded_encodableData}), true);
'''
'''
    const errors:Array<string> = [];
    try {
        asInstanceOfEncodableKeyTypes({
            ...good(),
            str_key:null
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'attribute str_key is invalid because Error: null is not a { [key: string]: number } because Error: null is not an object it is null');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableKeyTypes({
            ...good(),
            int_key:null
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'Error: { str_key:{ fred:3 }, int_key:null, more_keys:{ 9:2, null:1, 5.5:3, true:4 }, duration_key:{ 77.2:1 }, timestamp_key:{ 88.1:1 }, non_str_literal_key:{ 10:1, true:2 }, str_literal_key:{ a\\n"nail"\\'s tip:3, fred:4, rooster:5 }, enum_key:{ fred:1, jock:2 }, custom_key:{ 3221751809:1 }, alt_custom_key:{ 192.8.8.1/24:1 }, newstr_key:{ red:1, green:2 }, newfloat_key:{ 22:1 }, newint_key:{ 7:1 }, newbool_key:{ false:1 }, any_key:{ 8:1, fred:2, null:3, 7.6:4, true:5 } } is not a EncodableKeyTypes because Error: attribute int_key is invalid because Error: null is not a { [key: string /* int */]: number } because Error: null is not an object it is null');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableKeyTypes({
            ...good(),
            more_keys:null
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'attribute more_keys is invalid because Error: null is not a { [key: string /* string ** null **|string ** xju.misc.ByteCount **|string ** float **|string ** bool ** */]: number } because Error: null is not an object it is null');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableKeyTypes({
            ...good(),
            duration_key:null
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'attribute duration_key is invalid because Error: null is not a { [key: string /* xju.time.Duration */]: number } because Error: null is not an object it is null');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableKeyTypes({
            ...good(),
            timestamp_key:null
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'attribute timestamp_key is invalid because Error: null is not a { [key: string /* xju.time.Timestamp */]: number } because Error: null is not an object it is null');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableKeyTypes({
            ...good(),
            non_str_literal_key:null
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), "attribute non_str_literal_key is invalid because Error: null is not a { [key: string /* '10'|'true' */]: number } because Error: null is not an object it is null");
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableKeyTypes({
            ...good(),
            str_literal_key:null
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'attribute str_literal_key is invalid because Error: null is not a { [key: string /* \\"a\\n\\"nail\\"\\'s tip\\"|O.a|string ** Surname ** */]: number } because Error: null is not an object it is null');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableKeyTypes({
            ...good(),
            enum_key:null
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'attribute enum_key is invalid because Error: null is not a { [key: string /* O */]: number } because Error: null is not an object it is null');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableKeyTypes({
            ...good(),
            custom_key:null
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'attribute custom_key is invalid because Error: null is not a { [key: string /* number ** IpV4Addr ** */]: number } because Error: null is not an object it is null');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableKeyTypes({
            ...good(),
            alt_custom_key:null
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'attribute alt_custom_key is invalid because Error: null is not a { [key: string /* string ** IpV4AddrWithPrefix ** */]: number } because Error: null is not an object it is null');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableKeyTypes({
            ...good(),
            newstr_key:null
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'attribute newstr_key is invalid because Error: null is not a { [key: string]: number } because Error: null is not an object it is null');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableKeyTypes({
            ...good(),
            newfloat_key:null
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'attribute newfloat_key is invalid because Error: null is not a { [key: string /* float */]: number } because Error: null is not an object it is null');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableKeyTypes({
            ...good(),
            newint_key:null
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'attribute newint_key is invalid because Error: null is not a { [key: string /* int */]: number } because Error: null is not an object it is null');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        asInstanceOfEncodableKeyTypes({
            ...good(),
            newbool_key:null
        });
        assert_never_reached();
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'attribute newbool_key is invalid because Error: null is not a { [key: string /* bool */]: number } because Error: null is not an object it is null');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    try {
        const x = asInstanceOfEncodableKeyTypes({
            ...good(),
            any_key:null
        });
        assert_not_equal(x, x);
    }
    catch(e){
        try{
            assert_x_contains_y(str(e), 'attribute any_key is invalid because Error: null is not a { [key: string]: any } because Error: null is not an object it is null');
        }
        catch(ee){
            errors.push(`${ee}`);
        }
    }
    assert_equal(errors, []);
})();
''')

print('''
//alias
(() => {
    var x:any = 8;
    var y:number|string = xju.asInstanceOfNorS(x);
    if (typeof y !== 'number') {
        throw new Error(`typeof y is ${typeof y} not number`);
    }
    assert_equal(y, 8);
    if (!xju.isInstanceOfNorS(x)) {
        throw new Error(`${y} (of type ${typeof y}) is not a NorS`);
    }
    assert_equal(x, 8);
})();
//NewInt alias
(() => {
    var x:any = 8;
    var y:xju.misc.ByteCount = xju.misc.asInstanceOfByteCount(x);
    assert_equal(y, 8);
    if (!xju.misc.isInstanceOfByteCount(x)) {
        throw new Error(`${y} (of type ${typeof y}) is not a xju.misc.ByteCount`);
    }
    assert_equal(x, 8);
})();
//NewFloat alias
(() => {
    var x:any = 8.8;
    var y:xju.time.Duration = xju.time.asInstanceOfDuration(x);
    assert_equal(y, 8.8);
    if (!xju.time.isInstanceOfDuration(x)) {
        throw new Error(`${y} (of type ${typeof y}) is not a xju.time.Duration`);
    }
    assert_equal(x, 8.8);
})();
//NewStr alias
(() => {
    var x:any = "fred";
    var y:xju.json_codec.TypeScriptUQN = xju.json_codec.asInstanceOfTypeScriptUQN(x);
    assert_equal(y, "fred");
    if (!xju.json_codec.isInstanceOfTypeScriptUQN(x)) {
        throw new Error(`${y} (of type ${typeof y}) is not a xju.json_codec.TypeScriptUQN`);
    }
    assert_equal(x, "fred");
})();
''')

print('''
//Lias
(() => {
    assert_equal(asInstanceOfLias({"x":8}),{x:8});
})();
''')

try:
    codec(int|str).add_typescript_alias(namespace, [TypeScriptUQN('xju'),TypeScriptUQN('NorS')])
except Exception as e:
    Assert(readable_repr(e)).contains('is already defined')
else:
    assert False
    pass

Assert(codec(int).typescript_as_object_key_type())==TypeScriptSourceCode("string /* int */")
Assert(codec(float).typescript_as_object_key_type())==TypeScriptSourceCode("string /* float */")
Assert(codec(bool).typescript_as_object_key_type())==TypeScriptSourceCode("string /* bool */")
Assert(codec(NoneType).typescript_as_object_key_type())==TypeScriptSourceCode("string /* null */")

try:
    codec(list[int]).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='Array<number> is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(list).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='Array<any> is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(set[int]).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='Array<number> /* with unique elements */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(set).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='Array<any> /* with unique elements */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(frozenset[int]).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='Array<number> /* with unique elements */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(frozenset).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='Array<any> /* with unique elements */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(tuple[bool]).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='[boolean] is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(dict).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='{ [key: string]: any } is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(dict[str,str]).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='{ [key: string]: string } is not allowed as a typescript object key type'
else:
    assert False
    pass

Assert(codec(ByteCount).typescript_as_object_key_type())==TypeScriptSourceCode('string /* xju.misc.ByteCount */')
Assert(codec(Duration).typescript_as_object_key_type())==TypeScriptSourceCode('string /* xju.time.Duration */')

Assert(codec(Timestamp).typescript_as_object_key_type())==TypeScriptSourceCode(
    "string /* xju.time.Timestamp */")

try:
    codec(NonStringKey).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='NonStringKey is not allowed as a typescript object key type'
else:
    assert False
    pass

Assert(codec(O).typescript_as_object_key_type())==TypeScriptSourceCode("string /* O */")

try:
    AnyJsonCodecImpl().typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='any is not allowed as a typescript object key type'
else:
    assert False
    pass
    
try:
    codec(FullName).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='FullName is not allowed as a typescript object key type'
else:
    assert False
    pass
    
try:
    codec(bytes).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='Array<number> /* bytes */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(Selfish).typescript_as_object_key_type()
except Exception as e:
    Assert(readable_repr(e))=='Selfish is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(Selfish).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Selfish is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(Selfish).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Selfish is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(list[int]).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Array<number> is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(list).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Array<any> is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(set[str]).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Array<string> /* with unique elements */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(set).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Array<any> /* with unique elements */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(frozenset[str]).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Array<string> /* with unique elements */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(frozenset).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Array<any> /* with unique elements */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(tuple[int,str]).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='[number,string] is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(tuple[int,str]).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='[number,string] is not allowed as a typescript object key type'
else:
    assert False
    pass

Assert(codec(dict[ByteCount,str]).decode({'38':'fred'}))=={ByteCount(38):'fred'}
Assert(codec(dict[ByteCount,str]).decode({38:'fred'}))=={ByteCount(38):'fred'}
Assert(codec(dict[ByteCount,str]).encode({ByteCount(38):'fred'}))=={38:'fred'}

Assert(codec(dict[bool|ByteCount,str]).decode({'38':'fred'}))=={ByteCount(38):'fred'}
Assert(codec(dict[bool|ByteCount,str]).decode({38:'fred'}))=={ByteCount(38):'fred'}
Assert(codec(dict[bool|ByteCount,str]).encode({ByteCount(38):'fred'}))=={38:'fred'}
Assert(codec(dict[bool|ByteCount,str]).decode({'true':'fred'}))=={True:'fred'}
Assert(codec(dict[bool|ByteCount,str]).decode({True:'fred'}))=={True:'fred'}
Assert(codec(dict[bool|ByteCount,str]).encode({True:'fred'}))=={True:'fred'}

Assert(codec(dict[Surname|str,str]).decode({'Jones':'fred'}))=={Surname('Jones'):'fred'}
Assert(codec(dict[Surname|str,str]).decode({'Mc Sweeney':'fred'}))=={'Mc Sweeney':'fred'}
Assert(codec(dict[Surname|str,str]).encode({Surname('Jones'):'fred'}))=={'Jones':'fred'}

Assert(codec(dict[Surname,str]).decode({'Jones':'fred'}))=={Surname('Jones'):'fred'}
Assert(codec(dict[Surname,str]).encode({Surname('Jones'):'fred'}))=={'Jones':'fred'}

c=codec(dict[int|bool,float])
try:
    c.decode({'fred':8.2})
except Exception as e:
    Assert(readable_repr(e))=="Failed to decode {'fred': 8.2} to a dict[int | bool, float] because\n- failed to decode key 'fred' via json.loads because\n  Expecting value: line 1 column 1 (char 0); and\n- failed to decode key 'fred' directly because\n  failed to decode 'fred' as one of (<class 'int'>, <class 'bool'>) because\n  - failed to decode as <class 'int'> because\n    'fred' (of type <class 'str'>) is not a <class 'int'>; and\n  - failed to decode as <class 'bool'> because\n    'fred' (of type <class 'str'>) is not a <class 'bool'>."
else:
    assert False
    pass

try:
    codec(dict[dict[int,bool],str]).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=='{ [key: string /* int */]: boolean } is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(dict[dict,str]).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=='{ [key: string]: any } is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(dict[JsonType,str]).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=="Failed to get typescript type of dictionary key that is any of (<class 'NoneType'>, <class 'bool'>, <class 'dict'>, <class 'list'>, <class 'float'>, <class 'str'>) because\n{ [key: string]: any } is not allowed as a typescript object key type."
else:
    assert False
    pass

try:
    codec(bytes).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=='Array<number> /* bytes */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(dict).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=='{ [key: string]: any } is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(JsonType).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=='{ [key: string]: any } is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(list[int]).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Array<number> is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(list).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Array<any> is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(set[str]).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Array<string> /* with unique elements */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(set).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Array<any> /* with unique elements */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(frozenset[str]).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Array<string> /* with unique elements */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(frozenset).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='Array<any> /* with unique elements */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(tuple[int,str]).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='[number,string] is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(tuple[int,str]).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='[number,string] is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(dict[dict[int,bool],str]).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=='{ [key: string /* int */]: boolean } is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(dict[dict,str]).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=='{ [key: string]: any } is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    AnyJsonCodecImpl().get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='any is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(bytes).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=='Array<number> /* bytes */ is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(dict).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=='{ [key: string]: any } is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    AnyJsonCodecImpl().get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)
except Exception as e:
    Assert(readable_repr(e))=='any is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(FullName).get_typescript_isa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=='FullName is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(FullName).get_typescript_asa_key(TypeScriptSourceCode('k'),namespace)  # type: ignore  # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e))=='FullName is not allowed as a typescript object key type'
else:
    assert False
    pass

try:
    codec(dict[list[int],str]).get_json_schema()  # type: ignore # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e)).contains("list is not allowed as json object key type")
else:
    assert False
    pass

try:
    codec(dict[list,str]).get_json_schema()  # type: ignore # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e)).contains("list is not allowed as json object key type")
else:
    assert False
    pass

try:
    codec(dict[set[str],str]).get_json_schema()  # type: ignore # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e)).contains("set is not allowed as json object key type")
else:
    assert False
    pass

try:
    codec(dict[frozenset[str],str]).get_json_schema()  # type: ignore # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e)).contains("frozenset is not allowed as json object key type")
else:
    assert False
    pass

try:
    codec(dict[set,str]).get_json_schema()  # type: ignore # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e)).contains("set is not allowed as json object key type")
else:
    assert False
    pass

try:
    codec(dict[frozenset,str]).get_json_schema()  # type: ignore # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e)).contains("frozenset is not allowed as json object key type")
else:
    assert False
    pass

try:
    codec(dict[tuple[int,str],str]).get_json_schema()  # type: ignore # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e)).contains("tuple is not allowed as json object key type")
else:
    assert False
    pass

try:
    codec(dict[dict[int,str],str]).get_json_schema()  # type: ignore # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e)).contains("dict is not allowed as json object key type")
else:
    assert False
    pass

try:
    codec(dict[dict,str]).get_json_schema()  # type: ignore # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e)).contains("dict is not allowed as json object key type")
else:
    assert False
    pass

try:
    # unreachable via codec()
    AnyJsonCodecImpl().get_object_key_json_schema({})
except Exception as e:
    Assert(readable_repr(e)).contains("any json type is not allowed as json object key type")
else:
    assert False
    pass

try:
    codec(dict[bytes,str]).get_json_schema()  # type: ignore # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e)).contains("bytes is not allowed as json object key type")
else:
    assert False
    pass

try:
    codec(dict[FullName,str]).get_json_schema()  # type: ignore # json_codec_plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e)).contains("FullName is not allowed as json object key type")
else:
    assert False
    pass
