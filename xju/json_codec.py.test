#!/usr/bin/env python3

# Copyright (c) 2022 Trevor Taylor
# coding: utf-8
# 
# Permission to use, copy, modify, and/or distribute this software for
# any purpose with or without fee is hereby granted, provided that all
# copyright notices and this permission notice appear in all copies.
# 
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#
from sys import path
from os.path import dirname
if path[0]==dirname(__file__): path.pop(0)

from xju.json_codec import (
    codec,
    JsonType,
    AnyJsonCodecImpl,
    encode_attr_as,
    dont_encode_attr,
    TypeScriptSourceCode,
    TypeScriptNamespace,
    CustomClassCodec,
    CustomStringKeyClassCodec,
    CustomNonStringKeyClassCodec,
    CustomGenericClassCodec,
    CustomStringKeyGenericClassCodec,
    PythonAttrName,
    JsonAttrName,
    BackRefCodecImpl,
    NoopCodecImpl,
    indent,
    get_default_value,
    CodecProto
)

from typing import cast,Type,Literal,Any,Self,NewType,Generic,TypeVar,Callable,Union,Final,ClassVar
from typing import Final, Sequence, Protocol
from types import NoneType
from dataclasses import dataclass, field
import re
import sys
from ipaddress import IPv4Address,IPv4Interface,IPv4Network
from enum import Enum, StrEnum, IntEnum, auto

from xju.assert_ import Assert
import xju.newtype
from xju.xn import readable_repr
from xju.time import Timestamp
import xju

x:Any

# int,str,bool,float,None map directly

Assert(codec(int).decode(3))==3
Assert(codec(str).decode('fred'))=='fred'
Assert(codec(bool).decode(True))==True
Assert(codec(float).decode(5.5))==5.5
Assert(codec(float).decode(5))==5.0

Assert(codec(int).encode(3))==3
Assert(codec(str).encode('fred'))=='fred'
Assert(codec(bool).encode(True))==True
Assert(codec(float).encode(5.5))==5.5
Assert(codec(float).encode(5))==5

# and can use NewType of int,str,bool,float
Colour = NewType('Colour',str)
Assert(codec(Colour).decode('red'))==Colour('red')
Assert(codec(Colour).encode(Colour('red')))=='red'
Milligrams = NewType('Milligrams',float)
Assert(codec(Milligrams).decode(7.6))==Milligrams(7.6)
Assert(codec(Milligrams).encode(Milligrams(7.6)))==7.6
Votes = NewType('Votes',int)
Assert(codec(Votes).decode(7))==Votes(7)
Assert(codec(Votes).encode(Votes(7)))==7
Enabled = NewType('Enabled',bool)
Assert(codec(Enabled).decode(True))==Enabled(True)
Assert(codec(Enabled).decode(False))==Enabled(False)
Assert(codec(Enabled).encode(Enabled(True)))==True
Assert(codec(Enabled).encode(Enabled(False)))==False

# note None is a not a type, its type is NoneType
Assert(codec(NoneType).decode(None))==None
Assert(codec(NoneType).encode(None))==None


# type-adorned list maps to list...
Assert(codec(list[int]).decode([5, 6]))==[5, 6]
Assert(codec(list[int]).encode([5, 6]))==[5, 6]

# ... but must be given a list...
try:
    x=codec(list[int]).decode(8)
except Exception as e:
    Assert("8 is not a list").isIn(str(e))
else:
    assert False, x
    pass

# ... unadorned list is treated as list[JsonType]...
Assert(codec(list).decode([5, 'fred']))==[5, 'fred']
Assert(codec(list).encode([5, 'fred']))==[5, 'fred']

# ... but must be given a list
try:
    x=codec(list).decode(8)
except Exception as e:
    Assert("8 is not a list").isIn(str(e))
else:
    assert False, x
    pass

# ... and all values must have correct type
try:        
    x=codec(list[int]).decode([5, 'fred'])
except Exception as e:
    Assert("'fred' (of type <class 'str'>) is not a <class 'int'>").isIn(str(e))
else:
    assert False, x
    pass


# type-adorned set maps to list...
Assert(codec(set[int]).decode([5, 6]))==set([5, 6])
Assert(codec(set[int]).encode(set([5, 6])))==[5, 6]
Assert(codec(frozenset[int]).decode([5, 6]))==frozenset([5, 6])
Assert(codec(frozenset[int]).encode(frozenset([5, 6])))==[5, 6]

# ... but must be given a set...
try:
    x=codec(set[int]).decode(8)
except Exception as e:
    Assert("8 is not a set").isIn(str(e))
else:
    assert False, x
    pass

try:
    x=codec(frozenset[int]).decode(8)
except Exception as e:
    Assert("8 is not a frozenset").isIn(str(e))
else:
    assert False, x
    pass

# ... and all values must have correct type
try:        
    x=codec(set[int]).decode([5, 'fred'])
except Exception as e:
    Assert("'fred' (of type <class 'str'>) is not a <class 'int'>").isIn(str(e))
else:
    assert False, x
    pass
try:        
    x=codec(frozenset[int]).decode([5, 'fred'])
except Exception as e:
    Assert("'fred' (of type <class 'str'>) is not a <class 'int'>").isIn(str(e))
else:
    assert False, x
    pass


# ... and elements must be unique
try:
    x=codec(set[int]).decode([1,2,3,2])
except Exception as e:
    Assert('[1, 2, 3, 2] contains at least one duplicate element').isIn(str(e))
else:
    assert False, x
    pass
try:
    x=codec(frozenset[int]).decode([1,2,3,2])
except Exception as e:
    Assert('[1, 2, 3, 2] contains at least one duplicate element').isIn(str(e))
else:
    assert False, x
    pass

# ... un-typed set is treated as set[JsonType]...
Assert(codec(set).decode([5, 'fred']))==set([5, 'fred'])
set_result=codec(set).encode(set([5, 'fred']))
assert isinstance(set_result,list)
Assert(set(set_result))==set([5, 'fred'])
Assert(codec(frozenset).decode([5, 'fred']))==frozenset([5, 'fred'])
frozenset_result=codec(frozenset).encode(frozenset([5, 'fred']))
assert isinstance(frozenset_result,list)
Assert(frozenset(frozenset_result))==frozenset([5, 'fred'])

# ... but must be given a set
try:
    x=codec(set).decode(8)
except Exception as e:
    Assert("8 is not a list").isIn(str(e))
else:
    assert False, x
    pass
try:
    x=codec(frozenset).decode(8)
except Exception as e:
    Assert("8 is not a list").isIn(str(e))
else:
    assert False, x
    pass

# ... and elements must be unique
try:
    x=codec(set).decode([1,2,3,2])
except Exception as e:
    Assert('[1, 2, 3, 2] contains at least one duplicate element').isIn(str(e))
else:
    assert False, x
    pass
try:
    x=codec(frozenset).decode([1,2,3,2])
except Exception as e:
    Assert('[1, 2, 3, 2] contains at least one duplicate element').isIn(str(e))
else:
    assert False, x
    pass


# bytes maps to list of number...
Assert(codec(bytes).encode(b'\x1b\x17'))==[27,23]
Assert(codec(bytes).decode([27,23]))==b'\x1b\x17'

# ... but must be given bytes to encode...
try:
    x=(
        codec(bytes)
    ).encode(8)  # type: ignore
except Exception as e:
    Assert("8 is not of type bytes").isIn(str(e))
else:
    assert False, x
    pass

# ... and all values must have correct type
try:        
    x=codec(bytes).decode([5, 'fred'])
except Exception as e:
    Assert("'fred' (of type <class 'str'>) is not a <class 'int'>").isIn(str(e))
else:
    assert False, x
    pass

# tuple maps to list...
tuple_codec=codec(tuple[int,str])
Assert(tuple_codec.decode([5, 'fred']))==(5, 'fred')
Assert(codec(tuple[int,str]).encode((5, 'fred')))==[5, 'fred']
Assert(tuple_codec.encode((5, 'fred')))==[5, 'fred']
# same as...
Assert(codec(tuple[int,str]).decode([5, 'fred']))==(5, 'fred')
Assert(codec(tuple[int,str]).encode((5, 'fred')))==[5, 'fred']

# ... for list to decode as tuple, it must be a list in the first place...
try:        
    x=tuple_codec.decode({'x':6, 'y':8})
except Exception as e:
    Assert("{'x': 6, 'y': 8} is not a list").isIn(str(e))
else:
    assert False, x
    pass

# ... it must have expected number of elements...
try:        
    x=tuple_codec.decode([5, 6, 7])
except Exception as e:
    Assert("[5, 6, 7] does not have 2 items (it has 3 items)").isIn(str(e))
else:
    assert False, x
    pass

# ... each element must have correct type:
try:
    x=tuple_codec.decode([5, 6])
except Exception as e:
    Assert("6 (of type <class 'int'>) is not a <class 'str'>").isIn(str(e))
else:
    assert False, x
    pass

# encoding also rejects wrong number of elements, but this would be
# rejected by type checker anyway
try:
    x=tuple_codec.encode((5, 6, 7))  # type: ignore
except Exception as e:
    Assert("(5, 6, 7) does not have 2 items (it has 3 items)").isIn(str(e))
else:
    assert False, x
    pass


# dict with no type hints allows any keys with any value types (key must be string)
Assert(codec(dict).decode({'fred':5, 'jock': 'nine'}))=={'fred':5, 'jock':'nine'}
Assert(codec(dict).encode({'fred':5, 'jock': 'nine'}))=={'fred':5, 'jock':'nine'}


# dict with specific value type, keys can be str...
Assert(codec(dict[str,int]).decode({'fred':5, 'jock': 9}))=={'fred':5, 'jock':9}
Assert(codec(dict[str,int]).encode({'fred':5, 'jock': 9}))=={'fred':5, 'jock':9}

#... or xju.newtype.Str...
class SurnameTag:pass
class Surname(xju.newtype.Str[SurnameTag]):
    pattern=re.compile(r'^\S*$')  # disallow whitespace
    pass
Assert(codec(dict[Surname,int]).encode({Surname("yo"):3}))=={"yo":3}
Assert(codec(dict[Surname,int]).decode({"yo":3}))=={Surname("yo"):3}

#... or int/float/bool/None
Assert(codec(dict[int,int]).decode({1:5, 2: 9}))=={1:5, 2:9}
Assert(codec(dict[float,int]).decode({6.5:5, 8: 9}))=={6.5:5, 8:9}
Assert(codec(dict[bool,int]).decode({True:5, False: 9}))=={True:5, False:9}
Assert(codec(dict[None,int]).decode({None:5}))=={None:5}
Assert(codec(dict[int,int]).encode({1:5, 2: 9}))=={1:5, 2:9}
Assert(codec(dict[float,int]).encode({6.5:5, 8: 9}))=={6.5:5, 8:9}
Assert(codec(dict[bool,int]).encode({True:5, False: 9}))=={True:5, False:9}
Assert(codec(dict[None,int]).encode({None:5}))=={None:5}

#... or unions of those
Assert(codec(dict[int|float|bool|None,int]).decode({1:5, 2.5: 10, True: 11, None: 12}))=={
    1:5, 2.5: 10, True: 11, None: 12}
Assert(codec(dict[int|float|bool|None,int]).encode({1:5, 2.5: 10, True: 11, None: 12}))=={
    1:5, 2.5: 10, True: 11, None: 12}

# ... must be given a dict...
try:
    x=codec(dict).decode(7)
except Exception as e:
    Assert("7 is not a dict").isIn(str(e))
else:
    assert False, x
    pass
try:
    x=codec(dict[str,int]).decode(7)
except Exception as e:
    Assert("7 is not a dict").isIn(str(e))
else:
    assert False, x
    pass

# ... expects all elements to have that value type incorrect dict value type
try:
    x=codec(dict[str,int]).decode({'jock': 'fred'})
except Exception as e:
    Assert("'fred' (of type <class 'str'>) is not a <class 'int'>").isIn(str(e))
else:
    assert False, x
    pass

# dict keys must be strings or xju.newtype.Str...
try:
    x=(
        codec(dict)
    ).encode({6: 'fred'})  # type: ignore
except Exception as e:
    Assert(str(e)).matches("6 is not a <class 'str'>")
else:
    assert False, x
    pass

# ... must be given a dict...
try:
    x=(
        codec(dict)
    ).encode(7) # type: ignore
except Exception as e:
    Assert("7 is not a dict").isIn(str(e))
else:
    assert False, x
    pass
try:
    x=(
        codec(dict[str,int])
    ).encode(7) # type: ignore
except Exception as e:
    Assert("7 is not a dict").isIn(str(e))
else:
    assert False, x
    pass

#xju.newtype.Int support
class AgeInYearsTag:pass
class AgeInYears(xju.newtype.Int[AgeInYearsTag]):pass

Assert(codec(AgeInYears).decode(3))==AgeInYears(3)
Assert(codec(AgeInYears).encode(AgeInYears(3)))==3

try:
    x=codec(AgeInYears).decode('fred')
except Exception as e:
    Assert("'fred' (of type <class 'str'>) is not an int").isIn(str(e))
else:
    assert False, x
    pass

try:        
    x=(
        codec(AgeInYears)
    ).encode(8) # type: ignore
except Exception as e:
    Assert("8 is not a <class '__main__.AgeInYears'>").isIn(str(e))
else:
    assert False, x
    pass

#xju.newtype.Float support
class MetresTag:pass
class Metres(xju.newtype.Float[MetresTag]):pass

Assert(codec(Metres).decode(3.8))==Metres(3.8)
Assert(codec(Metres).encode(Metres(3.8)))==3.8
Assert(codec(Metres).decode(3))==Metres(3)
Assert(codec(Metres).encode(Metres(3)))==3

try:
    x=codec(Metres).decode('fred')
except Exception as e:
    Assert("'fred' (of type <class 'str'>) is not a float (or an int)").isIn(str(e))
else:
    assert False, x
    pass

try:
    x=(
        codec(Metres)
    ).encode('fred') # type: ignore
except Exception as e:
    Assert("'fred' is not a <class '__main__.Metres'>").isIn(str(e))
else:
    assert False, x
    pass

#xju.newtype.Str support
Assert(codec(Surname).decode('Ang'))==Surname('Ang')
Assert(codec(Surname).encode(Surname('Ang')))=='Ang'

try:
    x=codec(Surname).decode(17)
except Exception as e:
    Assert("17 (of type <class 'int'>) is not an str").isIn(str(e))
else:
    assert False, x
    pass

try:
    x=(
        codec(Surname)
    ).encode(17) # type: ignore
except Exception as e:
    Assert("17 is not a <class '__main__.Surname'>").isIn(str(e))
else:
    assert False, x
    pass


# xju.time.Timestamp maps to float
Assert(codec(Timestamp).encode(Timestamp(3)))==3.0
Assert(codec(xju.time.Timestamp).encode(Timestamp(3)))==3.0
Assert(codec(xju.time.Timestamp).decode(3.0))==Timestamp(3)
try:
    x=codec(xju.time.Timestamp).encode('fred') # type:ignore
except Exception as e:
    Assert(readable_repr(e))=="'fred' is not a <class 'xju.time.Timestamp'>"
else:
    assert False,x
try:
    x=codec(xju.time.Timestamp).decode('fred')
except Exception as e:
    Assert(readable_repr(e))=="Failed to decode fred to a <class 'xju.time.Timestamp'> because\n'fred' (of type <class 'str'>) is not a float (or an int)."
else:
    assert False,x

#enum support...

class O(Enum):
    a='fred'
    b=7
    pass

OA = O

#... member codecs...
Assert(codec(Literal[O.b]).decode(7))==O.b
Assert(codec(Literal[O.a]).decode('fred'))==O.a
Assert(codec(Literal[O.a]).encode(O.a))=='fred'
Assert(codec(Literal[OA.a]).encode(O.a))=='fred'
try:
    x=codec(Literal[O.a]).decode(7)
except Exception as e:
    Assert(readable_repr(e))=="Failed to decode 7 to a typing.Literal[<O.a: 'fred'>] because\nfailed to decode 7 as O.a because\n7 (of type <class 'int'>) is not a <class 'str'>."
else:
    assert False, x
try:
    x=codec(Literal[O.a]).decode('jock')
except Exception as e:
    Assert(readable_repr(e))=="Failed to decode jock to a typing.Literal[<O.a: 'fred'>] because\nfailed to decode 'jock' as O.a because\n'jock' is not 'fred'."
else:
    assert False, x
try:
    x=(
        codec(Literal[O.a])
    ).encode(O.b)  # type: ignore
except Exception as e:
    Assert(readable_repr(e))=='Failed to encode <O.b: 7> as a O.a because\nO.b != O.a.'
else:
    assert False, x

#... enum codec itself
Assert(codec(O).decode('fred'))==O.a
Assert(codec(O).decode(7))==O.b
Assert(codec(O).encode(O.a))=='fred'
Assert(codec(O).encode(O.b))==7
try:
    x=codec(O).decode(8)
except Exception as e:
    Assert(readable_repr(e))=="Failed to decode 8 to a <enum 'O'> because\nfailed to decode 8 as enum O value because\n- failed to decode as O.a because\n  failed to decode 8 as O.a because\n  8 (of type <class 'int'>) is not a <class 'str'>; and\n- failed to decode as O.b because\n  failed to decode 8 as O.b because\n  8 is not 7."
else:
    assert False, x
try:
    x=codec(O).decode('jock')
except Exception as e:
    Assert(readable_repr(e))=="Failed to decode jock to a <enum 'O'> because\nfailed to decode 'jock' as enum O value because\n- failed to decode as O.a because\n  failed to decode 'jock' as O.a because\n  'jock' is not 'fred'; and\n- failed to decode as O.b because\n  failed to decode 'jock' as O.b because\n  'jock' (of type <class 'str'>) is not a <class 'int'>."
else:
    assert False, x
try:
    x=(
        codec(O)
    ).encode(7.1)  # type: ignore
except Exception as e:
    Assert(readable_repr(e))=="Failed to encode <enum 'O'> value 7.1 because\n7.1 (of type float) is not a O."
else:
    assert False, x

# mixed-in enum type
@dataclass(init=False)
class MixedEnumValue:
    def __init__(self, *args, **argv):
        match len(args):
            case 0:
                self.k = argv['k']
                self.v = argv['v']
            case 1:
                self.k, self.v = args[0].k, args[0].v
            case _:
                self.k, self.v = args

    k: int
    v: str

class MixedEnum(MixedEnumValue, Enum):
    a = MixedEnumValue(1, 'fred')
    b = MixedEnumValue(2, 'jock')
    pass

Assert(codec(MixedEnum).encode(MixedEnum.a)) == {'k': 1, 'v': 'fred'}
Assert(codec(MixedEnum).decode({'k': 1, 'v': 'fred'})) == MixedEnum.a

# type unions, e.g. str|int match either type

union_codec=codec(str|int)
Assert(union_codec.decode('fred'))=='fred'
Assert(union_codec.decode(9))==9
Assert(union_codec.encode('fred'))=='fred'
Assert(union_codec.encode(9))==9

#incorrect dict value type
try:
    x=union_codec.decode(5.7)
except Exception as e:
    Assert(str(e)).matches("failed to decode 5.7 to a str | int because.*failed to decode as <class 'str'> because 5.7 (of type <class 'float'>) is not a <class 'str'> and failed to decode as <class 'int'> because 5.7 (of type <class 'float'>) is not a <class 'int'>")
else:
    assert False, x
    pass

# ... note no need to alias
Assert(codec(str|int).decode('fred'))=='fred'
Assert(codec(str|int).decode(9))==9
Assert(codec(str|int).encode('fred'))=='fred'
Assert(codec(str|int).encode(9))==9


# Literal
Fred=Literal['fred']
Assert(codec(Fred).decode('fred'))=='fred'
Assert(codec(Fred).encode('fred'))=='fred'
# ... same as:
Assert(codec(Literal['fred']).decode('fred'))=='fred'
Assert(codec(Literal['fred']).encode('fred'))=='fred'

FredOrJock=Literal['fred','jock']
Assert(codec(FredOrJock).decode('fred'))=='fred'
Assert(codec(FredOrJock).decode('jock'))=='jock'
Assert(codec(FredOrJock).encode('fred'))=='fred'
Assert(codec(FredOrJock).encode('jock'))=='jock'
# ... same as:
Assert(codec(Literal['fred','jock']).decode('fred'))=='fred'
Assert(codec(Literal['fred','jock']).decode('jock'))=='jock'
Assert(codec(Literal['fred','jock']).encode('fred'))=='fred'
Assert(codec(Literal['fred','jock']).encode('jock'))=='jock'

Seven=Literal[7]
Assert(codec(Seven).decode(7))==7
Assert(codec(Seven).encode(7))==7

SevenOrEight=Literal[7,8]
Assert(codec(SevenOrEight).decode(7))==7
Assert(codec(SevenOrEight).decode(8))==8
Assert(codec(SevenOrEight).encode(7))==7
Assert(codec(SevenOrEight).encode(8))==8

LiterallyTrue=Literal[True]
LiterallyFalse=Literal[False]
Assert(codec(LiterallyTrue).decode(True))==True
Assert(codec(LiterallyFalse).encode(False))==False

LiterallyTrueOrFalse=Literal[True,False]
Assert(codec(LiterallyTrueOrFalse).decode(True))==True
Assert(codec(LiterallyTrueOrFalse).decode(False))==False
Assert(codec(LiterallyTrueOrFalse).encode(True))==True
Assert(codec(LiterallyTrueOrFalse).encode(False))==False

JockOr6=Literal[6,'jock']
Assert(codec(JockOr6).decode(6))==6
Assert(codec(JockOr6).decode('jock'))=='jock'
Assert(codec(JockOr6).encode(6))==6
Assert(codec(JockOr6).encode('jock'))=='jock'


#note python does not support float literals
v=3.4
try:
    codec(Literal[v])  # type: ignore
except Exception as e:
    Assert(readable_repr(e))=="Failed to explode type typing.Literal[3.4] into a tree of codecs using map {} to resolve any generic type refs i.e. TypeVars because\nfailed to create codec for literal value 3.4 because\n<class 'float'> literals are not supported (only support str, int, bool, Enum)."
else:
    assert False

#encode wrong type
try:
    x=(codec(FredOrJock)
       .encode(7)) # type: ignore
except Exception as e:
    Assert("7 is not 'fred'").isIn(str(e))
else:
    assert False, x
    pass
try:
    x=(codec(SevenOrEight)
       .encode(True)) # type: ignore
except Exception as e:
    Assert("True is not 7").isIn(str(e))
else:
    assert False, x
    pass
try:
    x=(codec(LiterallyTrueOrFalse)
       .encode('fred')) # type: ignore
except Exception as e:
    Assert("'fred' is not False").isIn(str(e))
    Assert("'fred' is not True").isIn(str(e))
else:
    assert False, x
    pass
#decode wrong type
try:
    x=codec(Fred).decode(7)
except Exception as e:
    Assert("7 is not a string").isIn(str(e))
else:
    assert False, x
    pass
try:
    x=codec(Seven).decode('fred')
except Exception as e:
    Assert("'fred' is not a int").isIn(str(e))
else:
    assert False, x
    pass
try:
    x=codec(LiterallyFalse).decode(7)
except Exception as e:
    Assert("7 is not a boolean").isIn(str(e))
else:
    assert False, x
    pass

# decode wrong value
try:
    FredOrAnn=Literal['fred','ann']
    x=codec(FredOrAnn).decode('jock')
except Exception as e:
    Assert(readable_repr(e))=="Failed to decode jock to a typing.Literal['fred', 'ann'] because\nfailed to decode 'jock' as one of ('fred', 'ann') because\n- failed to decode as 'fred' because\n  'jock' is not 'fred'; and\n- failed to decode as 'ann' because\n  'jock' is not 'ann'."
else:
    assert False, x
    pass
try:
    SixOrSeven=Literal[6,7]
    x=codec(SixOrSeven).decode(8)
except Exception as e:
    Assert(readable_repr(e))=="Failed to decode 8 to a typing.Literal[6, 7] because\nfailed to decode 8 as one of (6, 7) because\n- failed to decode as 6 because\n  8 is not 6; and\n- failed to decode as 7 because\n  8 is not 7."
else:
    assert False, x
    pass
try:
    x=codec(LiterallyFalse).decode(True)
except Exception as e:
    Assert("True is not False").isIn(str(e))
else:
    assert False, x
    pass


# class (object) support:
#   - encoding is dictionary containing each object attribute (except that string literal
#     attributes are treated specially, see string literal attributes below)
#   - when decoding, class is always initialised via keyword args (note that
#     dataclass generates __init__ function that supports keyword args)
#   - class may implement CustomClassCodec protocol for custom encodings, see
#     IpAddr below
@dataclass
class Address:
    street:'Street'
    suburb:'Suburb'
    postcode:'Postcode'
    _class: Literal["first", "second"]

class StreetTag:pass
class Street(xju.newtype.Str[StreetTag]):pass

class SuburbTag:pass
class Suburb(xju.newtype.Str[SuburbTag]):pass

class PostcodeTag:pass
class Postcode(xju.newtype.Int[PostcodeTag]):pass

# want Address._class to appear as "class" when encoded
# use encode_attr_as to map the name:
encode_attr_as(Address, PythonAttrName("_class"), JsonAttrName("class"))

# specified attr must exist:
try:
    encode_attr_as(Address, PythonAttrName("_classy"), JsonAttrName("class"))
except Exception as e:
    Assert("<class '__main__.Address'> apparently has no declared '_classy' attribute").isIn(str(e))
else:
    assert False

Assert(codec(Address).decode({
    'street':'alba',
    'suburb': 'bocca',
    'postcode': 3365,
    'class': 'second'}))==Address(Street('alba'),Suburb('bocca'),Postcode(3365),'second')
        
Assert(codec(Address).encode(Address(Street('alba'),Suburb('bocca'),Postcode(3365),'second')))=={
    'street':'alba',
    'suburb': 'bocca',
    'postcode': 3365,
    'class': 'second'}

# use dont_encode_attr to omit an attribute from json encoding:
@dataclass
class DontEncode:
    y: str
    cl: int = 3
    pass

dont_encode_attr(DontEncode, PythonAttrName("cl"))
Assert(codec(DontEncode).encode(DontEncode("fred")))=={'y':'fred'}
Assert(codec(DontEncode).decode({'y':'fred'})==DontEncode("fred"))

# ClassVar attrs are omitted from encoding automatically:
@dataclass
class ClassAttr:
    y: str
    cl: ClassVar[int] = 3
    cm: ClassVar[Callable[[], int] | None] = None
    pass

Assert(codec(ClassAttr).encode(ClassAttr("fred")))=={'y':'fred'}
Assert(codec(ClassAttr).decode({'y':'fred'})==ClassAttr("fred"))
       
# incorrect Address value type
try:
    x=codec(Address).decode({'jock': 'fred'})
except Exception as e:
    Assert(str(e)).matches(re.escape("failed to decode {'jock': 'fred'} to a <class '__main__.Address'> because"))
    Assert(str(e)).endswith("missing 4 required positional arguments: 'street', 'suburb', 'postcode', and '_class'")
else:
    assert False, x
    pass

try:
    x=(codec(Address)
       .encode(7)) # type: ignore
except Exception as e:
    Assert(str(e)).endswith("7 (of type <class 'int'>) is not a <class '__main__.Address'>")
else:
    assert False, x
    pass

bad_postcode=Address(Street('alba'),Suburb('bocca'),3365, 'second')  # type: ignore
try:
    x=codec(Address).encode(bad_postcode)
except Exception as e:
    Assert(str(e)).endswith("3365 is not a <class '__main__.Postcode'>")
else:
    assert False, x
    pass

class UnitTag: pass
class Unit(xju.newtype.Str[UnitTag]):
    pass

@dataclass
class ManagerName:
    a: str
    b: int

# class inheritance...
@dataclass
class UnitAddress(Address,ManagerName):
    unit:Unit

Assert(codec(UnitAddress).decode({
    'street':'alba',
    'suburb': 'bocca',
    'postcode': 3365,
    'class': 'first',
    'unit': '17a',
    'a': 'fred',
    'b': 17}))==UnitAddress('fred',17,Street('alba'),Suburb('bocca'),Postcode(3365),"first",Unit('17a'))

# ... encode will order attrs per python mro()
Assert(codec(UnitAddress).encode(
    UnitAddress('fred',17,Street('alba'),Suburb('bocca'),Postcode(3365),'second',unit=Unit('17a'))))=={
        'a': 'fred',
        'b': 17,
        'street':'alba',
        'suburb': 'bocca',
        'postcode': 3365,
        'class': 'second',
        'unit': '17a'}
Assert(list(cast(dict,codec(UnitAddress).encode(
    UnitAddress('fred',17,Street('alba'),Suburb('bocca'),Postcode(3365),'second',unit=Unit('17a')))).keys()))==[
        'a',
        'b',
        'street',
        'suburb',
        'postcode',
        'class',
        'unit']

# ... base class codec can encode subclass (but, obviously, cannot decode to subclass)
Assert(codec(Address).encode(
    UnitAddress(
        'fred',17,Street('alba'),Suburb('bocca'),Postcode(3365),'first',unit=Unit('17a'))))==codec(
            Address).encode(
                Address(Street('alba'),Suburb('bocca'),Postcode(3365),'first'))
       
# ... custom class encoding by implementing CustomClassCodec protocol, for example
# to support encoding of external types with control over their json representation
# ... to be usable as a dictionary key, the class also has to implement either
# the CustomStringKeyClassCodec or CustomNonStringKeyClassCodec
@dataclass
class Even:
    """note not usable as a dict key"""
    value: int  # ... -2, 0, 2, 4 ...
    __xju_json_codec=codec(int)

    def __post_init(self):
        assert self.value % 1 == 0, f"{self.value} is not an even number"
        pass
    
    # xju.json_codec.CustomClassCodec:
    @staticmethod
    def xju_json_codec_encode(x:"Even") -> JsonType:
        return Even.__xju_json_codec.encode(int(x.value/2))
    @staticmethod
    def xju_json_codec_decode(x:JsonType) -> "Even":
        return Even(Even.__xju_json_codec.decode(x)*2)
    @staticmethod
    def xju_json_codec_get_json_schema(definitions:dict[str,dict]) -> dict:
        '''return json schema for T'''
        '''- may add any supporting definitions to definitions'''
        return Even.__xju_json_codec.get_json_schema()
    @staticmethod
    def xju_json_codec_get_typescript_type() -> TypeScriptSourceCode:
        return TypeScriptSourceCode('number /* Even.value/2! */')
    @staticmethod
    def xju_json_codec_5_get_typescript_isa(
            namespace: TypeScriptNamespace) -> TypeScriptSourceCode:
        '''return typescript source that evaluates to a xju.json_codec.IsInstance
           - may add any supporting definitions to namespace, e.g. type for T itself'''
        return TypeScriptSourceCode(
            f"(x:any) => {{\n"
            f"    const r=xju.json_codec.isInstanceOfInt(x);\n"
            f"    return r;\n"
            f"}}")
    @staticmethod
    def xju_json_codec_5_get_typescript_asa(
            namespace: TypeScriptNamespace) -> TypeScriptSourceCode:
        '''return typescript source code that verifies {expression} with defaults applied would be a T and returns xju.json_codec.ApplyDefaults that would apply defaults, throwing an Error if {expression} is not valid as a T'''
        '''- may add any supporting definitions to namespace, e.g. type for T itself'''
        return TypeScriptSourceCode("\n".join([
            f"xju.json_codec.asInstanceInContext({{"
            ,f"    typeName: 'Even',"
            ,f"    f: (x:any) => {{"
            ,f"        return xju.json_codec.asInstanceOfInt('int').f(x);"
            ,f"    }}"
            ,f"}})"]))

assert isinstance(Even,CustomClassCodec)
assert not isinstance(Even,(CustomStringKeyClassCodec,CustomNonStringKeyClassCodec))

class IpV4Addr(IPv4Address):
    def __eq__(self, b) -> bool:
        return str(self)==str(b)
    def __hash__(self) -> int:
        return super().__hash__()

    __xju_json_codec=codec(int)

    # xju.json_codec.CustomClassCodec:
    @staticmethod
    def xju_json_codec_encode(x:object) -> JsonType:
        assert isinstance(x,IpV4Addr)
        return IpV4Addr.__xju_json_codec.encode(int(x))
    @staticmethod
    def xju_json_codec_decode(x:JsonType) -> object:
        return IpV4Addr(IpV4Addr.__xju_json_codec.decode(x))
    @staticmethod
    def xju_json_codec_get_json_schema(definitions:dict[str,dict]) -> dict:
        '''return json schema for T'''
        '''- may add any supporting definitions to definitions'''
        p=rf"([0-9]|([1][0-9])|([1][0-9][0-9])|(2[1-4][0-9])|(25[0-5]))"
        return {
            'description': f'IpV4Addr',
            'type': 'string',
            'pattern': rf'^{p}[.]{p}[.]{p}[.]{p}$'
        }
    @staticmethod
    def xju_json_codec_get_typescript_type() -> TypeScriptSourceCode:
        return TypeScriptSourceCode('number /* IpV4Addr */')
    @staticmethod
    def xju_json_codec_5_get_typescript_isa(
            namespace: TypeScriptNamespace) -> TypeScriptSourceCode:
        '''return typescript source that evaluates to a xju.json_codec.IsInstance
           - may add any supporting definitions to namespace, e.g. type for T itself'''
        return TypeScriptSourceCode(
            f"(x:any) => {{\n"
            f"    const r=xju.json_codec.isInstanceOfInt(x);\n"
            f"    if (r===false || (x as number) < 0 || (x as number >= {2**32-1})) {{\n"
            f"        return false;\n"
            f"    }}\n"
            f"    return r;\n"
            f"}}")
    @staticmethod
    def xju_json_codec_5_get_typescript_asa(
            namespace: TypeScriptNamespace) -> TypeScriptSourceCode:
        '''return typescript source code that verifies {expression} with defaults applied would be a T and returns xju.json_codec.ApplyDefaults that would apply defaults, throwing an Error if {expression} is not valid as a T'''
        '''- may add any supporting definitions to namespace, e.g. type for T itself'''
        return TypeScriptSourceCode("\n".join([
            f"xju.json_codec.asInstanceInContext({{"
            ,f"    typeName: 'IpV4Addr',"
            ,f"    f: (x:any) => {{"
            ,f"        const r=xju.json_codec.asInstanceOfInt('int').f(x);"
            ,f"        xju.assert.assertNumberInRange(x,0,{2**32-1});"
            ,f"        return r;"
            ,f"    }}"
            ,f"}})"]))

    # xju.json_codec.CustomNonStringKeyClassCodec:
    @staticmethod
    def xju_json_codec_get_object_key_json_schema(definitions:dict[str,dict]) -> dict:
        '''return json schema for T when used as an object key
           - may add any supporting definitions to definitions'''
        return {
            'description': "stringified-int IpV4Addr",
            'type': 'string',
            'pattern': r'^(0|[1-9][0-9]*)$'
        }

    @staticmethod
    def xju_json_codec_typescript_key_type()->Literal['NonString']:
        return 'NonString'
    
    @staticmethod
    def xju_json_codec_5_get_typescript_isa_key(
            namespace: TypeScriptNamespace) -> TypeScriptSourceCode:
        '''return typescript source code that evaluates to a xju.json_codec.IsKey
           - may add any supporting definitions to namespace, e.g. type for T itself'''
        return TypeScriptSourceCode(
            f"(x:any) => (xju.json_codec.isKeyOfInt(x) && (x as number) >= 0 && (x as number <= {2**32-1}))"
        )

    @staticmethod
    def xju_json_codec_5_get_typescript_asa_key(
            namespace: TypeScriptNamespace) -> TypeScriptSourceCode:
        '''return typescript source code that evaluates to a xju.json_codec.AsKey
           - may add any supporting definitions to namespace, e.g. type for T itself'''
        return TypeScriptSourceCode("\n".join([
            f"xju.json_codec.asKeyInContext({{"
            ,f"    typeName: 'IpV4Addr',"
            ,f"    f: (x:any) => {{"
            ,f"        xju.json_codec.asKeyOfInt('int').f(x);"
            ,f"        xju.assert.assertNumberInRange(x,0,{2**32-1});"
            ,f"    }}"
            ,f"}})"]))
    pass

Assert(IpV4Addr).isSubclassOf(CustomClassCodec)
Assert(IpV4Addr).isSubclassOf(CustomNonStringKeyClassCodec)

@dataclass
class IpV4AddrWithPrefix(IPv4Interface):
    """An IP host address in a network, e.g. 10.1.1.49/24"""
    if_str: str
    __codec=codec(str)
    def __post_init__(self):
        super().__init__(self.if_str)
        pass
    def __eq__(self, b) -> bool:
        return self.if_str == b.if_str
    def __hash__(self) -> int:
        return hash(self.if_str)
    @staticmethod
    def xju_json_codec_decode(x:JsonType) -> object:
        return IpV4AddrWithPrefix(IpV4AddrWithPrefix.__codec.decode(x))
    @staticmethod
    def xju_json_codec_encode(x:object) -> JsonType:
        assert isinstance(x,IpV4AddrWithPrefix)
        return IpV4AddrWithPrefix.__codec.encode(x.if_str)
    @staticmethod
    def xju_json_codec_get_json_schema(definitions:dict[str,dict]) -> dict:
        '''return json schema for T'''
        '''- may add any supporting definitions to definitions'''
        return IpV4AddrWithPrefix.__codec.get_json_schema()
    @staticmethod
    def xju_json_codec_get_typescript_type() -> TypeScriptSourceCode:
        return TypeScriptSourceCode('string /* IpV4AddrWithPrefix */')
    @staticmethod
    def xju_json_codec_5_get_typescript_isa(
            namespace: TypeScriptNamespace) -> TypeScriptSourceCode:
        '''return typescript source that evaluates to a xju.json_codec.IsInstance
           - may add any supporting definitions to namespace, e.g. type for T itself'''
        return TypeScriptSourceCode(
            f"(x:any) => {{\n"
            f"    if (!xju.json_codec.isInstanceOfString(x)) {{\n"
            f"        return false;\n"
            f"    }}\n"
            f"    const r=/^([0-9]+)[.]([0-9]+)[.]([0-9]+)[.]([0-9]+)[/]([0-9]+)$/.exec(x as string);\n"
            f"    if (r===null) {{\n"
            f"        return false;\n"
            f"    }}\n"
            f"    const [a,b,c,d,m] = r;\n"
            f"    return !([a,b,c,d].filter(v => parseInt(v) < 0 || parseInt(v) > 255).length ||\n"
            f"             parseInt(m) < 0 || parseInt(m) > 32) && xju.json_codec.applyNoDefaults;\n"
            f"}}")
    @staticmethod
    def xju_json_codec_5_get_typescript_asa(
            namespace: TypeScriptNamespace) -> TypeScriptSourceCode:
        '''return typescript source code that evaluates to a xju.json_codec.AsInstance
           - may add any supporting definitions to namespace, e.g. type for T itself'''
        return TypeScriptSourceCode(
            f"xju.json_codec.asInstanceInContext({{\n"
            f"    typeName: 'IpV4AddrWithPrefix',\n"
            f"    f: (x:any) => {{\n"
            f"        const r=xju.json_codec.asInstanceOfString('string').f(x);\n"
            f"        const [_,a,b,c,d,m]=xju.assert.assertMatches(\n"
            f"            /^([0-9]+)[.]([0-9]+)[.]([0-9]+)[.]([0-9]+)[/]([0-9]+)$/, x as string);\n"
            f"        [a,b,c,d].forEach(v=> xju.assert.assertNumberInRange(parseInt(v),0,255));\n"
            f"        xju.assert.assertNumberInRange(parseInt(m),0,32);\n"
            f"        return r;\n"
            f"    }}\n"
            f"}})")

    # xju.json_codec.CustomStringKeyClassCodec:
    @staticmethod
    def xju_json_codec_get_object_key_json_schema(definitions:dict[str,dict]) -> dict:
        '''return json schema for T when used as an object key
           - may add any supporting definitions to definitions'''
        return IpV4AddrWithPrefix.xju_json_codec_get_json_schema(definitions)
    @staticmethod
    def xju_json_codec_typescript_key_type()->Literal['String']:
        return 'String'
    @staticmethod
    def xju_json_codec_5_get_typescript_isa_key(
            namespace: TypeScriptNamespace) -> TypeScriptSourceCode:
        '''return typescript source code that evaluates to a xju.json_codec.IsKey
           - may add any supporting definitions to namespace, e.g. type for T itself'''
        return TypeScriptSourceCode(
            f"(x:any) => {{\n"
            f"    // note javascript turns the key into a string even if, say, it is a number\n"
            f"    const r=/^([0-9]+)[.]([0-9]+)[.]([0-9]+)[.]([0-9]+)[/]([0-9]+)$/.exec(x as string);\n"
            f"    if (r===null) {{\n"
            f"        return false;\n"
            f"    }}\n"
            f"    const [_,a,b,c,d,m] = r;\n"
            f"    return !([a,b,c,d].filter(v => parseInt(v) < 0 || parseInt(v) > 255).length ||\n"
            f"             parseInt(m) < 0 || parseInt(m) > 32);\n"
            f"}}")
    @staticmethod
    def xju_json_codec_5_get_typescript_asa_key(
            namespace: TypeScriptNamespace) -> TypeScriptSourceCode:
        '''return typescript source code that safely casts {expression} to a T, throwing an Error if {expression} is not valid as a T-as-object-key'''
        '''- may add any supporting definitions to namespace, e.g. type for T itself'''
        return TypeScriptSourceCode("\n".join([
            f"xju.json_codec.asKeyInContext({{"
            ,f"    typeName: 'IpV4Addr',"
            ,f"    f: (x:any) => {{"
            ,f"        // note javascript turns the key into a string even if, say, it is a number"
            ,f"        const [a,b,c,d,m]=xju.assert.assertMatches("
            ,f"            /^([0-9]+)[.]([0-9]+)[.]([0-9]+)[.]([0-9]+)[/]([0-9]+)$/, x as string);"
            ,f"        [a,b,c,d].forEach(v=> xju.assert.assertNumberInRange(parseInt(v),0,255));"
            ,f"        xju.assert.assertNumberInRange(parseInt(m),0,32);"
            ,f"    }}"
            ,f"}})"]))
    pass

Assert(IpV4AddrWithPrefix).isSubclassOf(CustomClassCodec)
Assert(IpV4AddrWithPrefix).isSubclassOf(CustomStringKeyClassCodec)

Assert(codec(IpV4AddrWithPrefix).get_json_schema())=={'type': 'string', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema', 'definitions': {}}

@dataclass
class Router:
    name: str
    ifv4: IpV4AddrWithPrefix

Assert(codec(Router).decode({'name':'fred','ifv4':'10.1.7.44/22'}))==Router(name='fred',ifv4=IpV4AddrWithPrefix('10.1.7.44/22'))
Assert(codec(Router).decode({'name':'fred','ifv4':'10.1.7.44/22'}).ifv4.network)==IPv4Network("10.1.4.0/22")
Assert(codec(Router).encode(Router(name='fred',ifv4=IpV4AddrWithPrefix('10.1.7.44/22'))))=={'name':'fred','ifv4':'10.1.7.44/22'}


# class does not have to be a dataclass...
class Ursula:
    def __eq__(self, b) -> bool:
        return isinstance(b, Ursula) and self.a == b.a and self.b == b.b

    a: int
    b: str
    def __init__(self, a: int, b: str):
        self.a = a
        self.b = b
    def g(self): pass
Assert(codec(Ursula).encode(Ursula(1, "fred")))=={"a": 1, "b": "fred"}
Assert(codec(Ursula).decode({"a": 1, "b": "fred"}))==Ursula(1, "fred")


# literal attributes match that string literal...
@dataclass
class Add:
    a:int
    b:int
    op_type: Literal['add'] # = 'add' not recommended - see Caution below

Assert(codec(Add).decode(
    {
        'op_type':'add',
        'a': 7,
        'b': 8
    }))==Add(7,8,op_type='add')
        
Assert(codec(Add).decode({
    'op_type':'add',
    'a': 7,
    'b': 8}).op_type)=='add'
        
Assert(codec(Add).encode(Add(7,8,op_type='add'))=={
    'op_type':'add',
    'a': 7,
    'b': 8})
        
# ... and rejected other values...
try:
    x=codec(Add).decode({
        'op_type':'subtract',
        'a': 7,
        'b': 8})
except Exception as e:
    Assert(str(e)).contains("'subtract' is not 'add'")
else:
    assert False, x
    pass

# ... allowing them to be used as type descriminators...
@dataclass
class MissingDefault:
    op_type: Literal['op']
    sub_type: Literal['plus']
    a:int
    b:int
    pass

Assert(codec(MissingDefault).decode({
    'op_type':'op',
    'sub_type':'plus',
    'a': 7,
    'b': 8}))==MissingDefault('op', 'plus', 7, 8)

# ... but always need to be passed literal value.

# Caution, giving the literal attribute a default seems
# like a useful shortcut since we know exactly what value
# to give it:
@dataclass
class Sub:
    a:int
    b:int
    op_type: Literal['sub'] = 'sub'

# ... but that will also match json with no op_type:
Assert(codec(Add|Sub).decode({
    'a': 7,
    'b': 8}))==Sub(7,8)



# misc coverage
Assert(repr(codec(int)))=="<class 'int'> json codec"


Assert(codec(int|None).decode(None))==None
Assert(codec(int|None).encode(None))==None

try:
    x=codec(int|None).decode('fred')
except Exception as e:
    Assert(str(e)).contains("'fred' is not None")
else:
    assert False, x
    pass

try:
    x=(codec(int|None)
       .encode('fred'))  # type: ignore
except Exception as e:
    Assert(str(e)).contains("'fred' is not None")
else:
    assert False, x
    pass


# Codec can generate corresponding json schema (http://json-schema.org)
# "null", "boolean", "object", "array", "number", "string", or "integer"
Assert(codec(NoneType).get_json_schema())=={'type': 'null', 'definitions': {}, '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'}
Assert(codec(int).get_json_schema())=={'type': 'integer', 'definitions': {}, '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'}
Assert(codec(bool).get_json_schema())=={'type': 'boolean', 'definitions': {}, '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'}
Assert(codec(str).get_json_schema())=={'type': 'string', 'definitions': {}, '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'}
Assert(codec(float).get_json_schema())=={'type': 'number', 'definitions': {}, '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'}
Assert(codec(list).get_json_schema())=={'type': 'array', 'definitions': {}, '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'}
Assert(codec(set).get_json_schema())=={'$ref': '#/definitions/set', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema', 'definitions': {'set': {'type': 'array', 'uniqueItems': True}}}
Assert(codec(frozenset).get_json_schema())=={'$ref': '#/definitions/frozenset', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema', 'definitions': {'frozenset': {'type': 'array', 'uniqueItems': True}}}
Assert(codec(list[int]).get_json_schema())=={'$ref': '#/definitions/list[int]', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema', 'definitions': {'list[int]': {'type': 'array', 'items': {'type': 'integer'}}}}
Assert(codec(set[int]).get_json_schema())=={'$ref': '#/definitions/set[int]', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema', 'definitions': {'set[int]': {'type': 'array', 'uniqueItems': True, 'items': {'type': 'integer'}}}}
Assert(codec(frozenset[int]).get_json_schema())=={'$ref': '#/definitions/frozenset[int]', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema', 'definitions': {'frozenset[int]': {'type': 'array', 'uniqueItems': True, 'items': {'type': 'integer'}}}}
Assert(codec(bytes).get_json_schema())=={'$ref': '#/definitions/bytes', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema', 'definitions': {'bytes': {'$ref': '#/definitions/list[int]'}}}
Assert(codec(tuple[int,str]).get_json_schema())=={'$ref': '#/definitions/tuple[int,str]', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema', 'definitions': {'tuple[int,str]': {'type': 'array', 'prefixItems': [{'type': 'integer'}, {'type': 'string'}]}}}

Assert(codec(JsonType).get_json_schema())=={'$ref': '#/definitions/None|bool|dict|list|float|str', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema', 'definitions': {'dict': {'type': 'object'}, 'None|bool|dict|list|float|str': {'oneOf': [{'type': 'null'}, {'type': 'boolean'}, {'$ref': '#/definitions/dict'}, {'type': 'array'}, {'type': 'number'}, {'type': 'string'}]}}}

Assert(codec(dict).get_json_schema())=={'$ref': '#/definitions/dict', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema', 'definitions': {'dict': {'type': 'object'}}}

Assert(codec(dict[str,int]).get_json_schema())=={'$ref': '#/definitions/dict[str,int]', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema', 'definitions': {'dict[str,int]': {'type': 'object', 'additionalProperties': {'type': 'integer'}}}}

any_json_codec_definitions=dict[str,dict]()
Assert((AnyJsonCodecImpl().get_json_schema(any_json_codec_definitions), any_json_codec_definitions))==({'$ref': '#/definitions/Any'}, {'Any': {'oneOf': [{'type': 'null'}, {'type': 'boolean'}, {'type': 'object'}, {'type': 'array'}, {'type': 'number'}, {'type': 'string'}]}})

Assert(codec(AgeInYears).get_json_schema())=={'$ref': '#/definitions/AgeInYears', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema', 'definitions': {'AgeInYears': {'type': 'integer'}}}

Assert(codec(Street).get_json_schema())=={'$ref': '#/definitions/Street', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema', 'definitions': {'Street': {'type': 'string'}}}

Assert(codec(Surname).get_json_schema())=={'$ref': '#/definitions/Surname', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema', 'definitions': {'Surname': {'type': 'string'}}}

Assert(codec(Metres).get_json_schema())=={'$ref': '#/definitions/Metres', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema', 'definitions': {'Metres': {'type': 'number'}}}

Assert(codec(Timestamp).get_json_schema())=={'$ref': '#/definitions/xju.time.Timestamp', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema', 'definitions': {'xju.time.Timestamp': {'type': 'number'}}}

Assert(codec(Fred).get_json_schema())=={'$ref': "#/definitions/Literal['fred']", '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema', 'definitions': {"Literal['fred']": {'type': 'string', 'enum': ['fred']}}}
Assert(codec(SevenOrEight).get_json_schema())=={'$ref': '#/definitions/Literal[7]|Literal[8]', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema', 'definitions': {'Literal[7]': {'type': 'number', 'enum': [7]}, 'Literal[8]': {'type': 'number', 'enum': [8]}, 'Literal[7]|Literal[8]': {'oneOf': [{'$ref': '#/definitions/Literal[7]'}, {'$ref': '#/definitions/Literal[8]'}]}}}
Assert(codec(LiterallyFalse).get_json_schema())=={'$ref': '#/definitions/Literal[False]', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema', 'definitions': {'Literal[False]': {'type': 'boolean', 'enum': [False]}}}
Assert(codec(O).get_json_schema())=={'$ref': '#/definitions/O', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema', 'definitions': {'O.a': {'type': 'string', 'enum': ['fred']}, 'O.b': {'type': 'integer', 'enum': [7]}, 'O': {'oneOf': [{'$ref': '#/definitions/O.a'}, {'$ref': '#/definitions/O.b'}]}}}

Assert(codec(Address).get_json_schema())=={
    '$ref': '#/definitions/Address', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema',
    'definitions': {
        'Street': {'type': 'string'},
        'Suburb': {'type': 'string'},
        'Postcode': {'type': 'integer'},
        "Literal['first']": {'type': 'string', 'enum': ['first']},
        "Literal['second']": {'type': 'string', 'enum': ['second']},
        "Literal['first']|Literal['second']": {
            'oneOf': [{'$ref': "#/definitions/Literal['first']"},
                      {'$ref': "#/definitions/Literal['second']"}]},
        'Address': {
            'description': 'Address',
            'type': 'object',
            'properties': {
                'street': {'$ref': '#/definitions/Street'},
                'suburb': {'$ref': '#/definitions/Suburb'},
                'postcode': {'$ref': '#/definitions/Postcode'},
                'class': {'$ref': "#/definitions/Literal['first']|Literal['second']"}}}}}

Assert(codec(IpV4Addr).get_json_schema())=={'description': 'IpV4Addr', 'type': 'string', 'pattern': r'^([0-9]|([1][0-9])|([1][0-9][0-9])|(2[1-4][0-9])|(25[0-5]))[.]([0-9]|([1][0-9])|([1][0-9][0-9])|(2[1-4][0-9])|(25[0-5]))[.]([0-9]|([1][0-9])|([1][0-9][0-9])|(2[1-4][0-9])|(25[0-5]))[.]([0-9]|([1][0-9])|([1][0-9][0-9])|(2[1-4][0-9])|(25[0-5]))$', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema', 'definitions': {}}

Assert(codec(MixedEnum).get_json_schema())=={'$ref': '#/definitions/MixedEnum', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema', 'definitions': {'MixedEnumValue': {'description': 'MixedEnumValue', 'type': 'object', 'properties': {'k': {'type': 'integer'}, 'v': {'type': 'string'}}}, 'MixedEnum.a': {'$ref': '#/definitions/MixedEnumValue', 'enum': [{'k': 1, 'v': 'fred'}]}, 'MixedEnum.b': {'$ref': '#/definitions/MixedEnumValue', 'enum': [{'k': 2, 'v': 'jock'}]}, 'MixedEnum': {'oneOf': [{'$ref': '#/definitions/MixedEnum.a'}, {'$ref': '#/definitions/MixedEnum.b'}]}}}

# recursive via Self
class LeafTag:pass
class Leaf(xju.newtype.Int[LeafTag]):pass

@dataclass
class Branch:
    shoots: list[Leaf|Self]
    pass

Tree = Branch|Leaf

Assert(codec(Branch).encode(Branch([Branch([Leaf(1),Leaf(2)]),Leaf(3)])))=={'shoots':[{'shoots':[1,2]},3]}
Assert(codec(Branch).decode({'shoots':[{'shoots':[1,2]},3]}))==Branch([Branch([Leaf(1),Leaf(2)]),Leaf(3)])
Assert(codec(Branch).get_json_schema())=={
    '$ref': '#/definitions/Branch',
    '$id': 'https://example.com/address.schema.json',
    '$schema': 'https://json-schema.org/draft/2020-12/schema',
    'definitions': {
        'Leaf': {'type': 'integer'},
        'Leaf|Branch': {'oneOf': [{'$ref': '#/definitions/Leaf'}, {'$ref': '#/definitions/Branch'}]},
        'list[Leaf|Branch]': {'type': 'array', 'items': {'$ref': '#/definitions/Leaf|Branch'}},
        'Branch': {'description': 'Branch', 'type': 'object', 'properties': {
            'shoots': {'$ref': '#/definitions/list[Leaf|Branch]'}}}}}

@dataclass
class Graph:
    value: int
    next: list[Self]
    pass

Assert(codec(Graph).encode(
    Graph(1, [Graph(2,[]),Graph(3,[])])))=={
        'value':1,'next':[
            {'value':2, 'next':[]},
            {'value':3, 'next':[]}]}
Assert(codec(Graph).get_json_schema())=={
    '$ref': '#/definitions/Graph',
    '$id': 'https://example.com/address.schema.json',
    '$schema': 'https://json-schema.org/draft/2020-12/schema',
    'definitions': {
        'list[Graph]': {'type': 'array', 'items': {'$ref': '#/definitions/Graph'}},
        'Graph': {'description': 'Graph', 'type': 'object', 'properties': {
            'value': {'type': 'integer'},
            'next': {'$ref': '#/definitions/list[Graph]'}}}}}

class AnIntEnum(IntEnum):
    a = 7
    b = auto()

try:
    import jsonschema # type: ignore
except:
    print('WARNING: skipped json_codec json_schema tests because jsonschema not importable',
          file=sys.stderr)
else:
    jsonschema.validate(None,codec(NoneType).get_json_schema())
    jsonschema.validate(7,codec(int).get_json_schema())
    jsonschema.validate(True,codec(bool).get_json_schema())
    jsonschema.validate('fred',codec(str).get_json_schema())
    jsonschema.validate(8.8,codec(float).get_json_schema())
    jsonschema.validate([1,True],codec(list).get_json_schema())
    jsonschema.validate([1,2],codec(list[int]).get_json_schema())
    jsonschema.validate([7,'fred'],codec(tuple[int,str]).get_json_schema())

    jsonschema.validate(None,codec(JsonType).get_json_schema())
    jsonschema.validate(True,codec(JsonType).get_json_schema())
    jsonschema.validate({},codec(JsonType).get_json_schema())
    jsonschema.validate([],codec(JsonType).get_json_schema())
    jsonschema.validate(9.9,codec(JsonType).get_json_schema())
    jsonschema.validate('fred',codec(JsonType).get_json_schema())

    jsonschema.validate({},codec(dict).get_json_schema())

    jsonschema.validate({'fred':2, 'jock':3},codec(dict[str,int]).get_json_schema())

    definitions: dict[str,dict]={}
    any_schema=AnyJsonCodecImpl().get_json_schema(definitions)
    any_schema.update({
        "$id": "https://example.com/address.schema.json",
        "$schema": "https://json-schema.org/draft/2020-12/schema"})
    any_schema.update({
        'definitions':definitions
    })
    jsonschema.validate(None,any_schema)
    jsonschema.validate(True,any_schema)
    jsonschema.validate({},any_schema)
    jsonschema.validate([],any_schema)
    jsonschema.validate(9.9,any_schema)
    jsonschema.validate('fred',any_schema)

    jsonschema.validate(77,codec(AgeInYears).get_json_schema())

    jsonschema.validate('pole',codec(Street).get_json_schema())

    jsonschema.validate(8.8,codec(Metres).get_json_schema())

    jsonschema.validate('fred',codec(Fred).get_json_schema())
    jsonschema.validate({
        'street':'alba',
        'suburb': 'bocca',
        'postcode': 3365,
        'class': 'first'},codec(Address).get_json_schema())
    jsonschema.validate(
        {'shoots':[{'shoots':[1,2]},3]},
        codec(Branch).get_json_schema())
    jsonschema.validate(
        {'shoots':[{'shoots':[1,2]},3]},
        codec(Branch).get_json_schema())
    jsonschema.validate(
        'fred',
        codec(Literal[O.a]).get_json_schema())
    jsonschema.validate(
        8.8,
        codec(Timestamp).get_json_schema())
    jsonschema.validate(
        {'7':'fred'},codec(dict[int,str]).get_json_schema())
    jsonschema.validate(
        {'7.9':'fred'},codec(dict[float,str]).get_json_schema())
    jsonschema.validate(
        {'true':'fred'},codec(dict[bool,str]).get_json_schema())
    jsonschema.validate(
        {'null':'fred'},codec(dict[None,str]).get_json_schema())
    jsonschema.validate(
        {'true':'fred', 8:'jock'},codec(dict[int|bool,str]).get_json_schema())
    jsonschema.validate(
        {'31':'fred'},codec(dict[AgeInYears,str]).get_json_schema())
    jsonschema.validate(
        {'10.8':'fred'},codec(dict[Metres,str]).get_json_schema())
    jsonschema.validate(
        {'Yeow':'fred'},codec(dict[Surname,str]).get_json_schema())
    jsonschema.validate(
        {'Big St':'fred'},codec(dict[Street,str]).get_json_schema())
    jsonschema.validate(
        {'100665':'fred'},codec(dict[Timestamp,str]).get_json_schema())
    jsonschema.validate(
        {'a':'b'},codec(dict[Literal["a"],str]).get_json_schema())
    jsonschema.validate(
        {'9':'b'},codec(dict[Literal[9],str]).get_json_schema())
    jsonschema.validate(
        {'false':'b'},codec(dict[Literal[False],str]).get_json_schema())
    jsonschema.validate(
        [4],codec(tuple[Even]).get_json_schema())
    jsonschema.validate(
        {'192.18.0.2':'b'},codec(dict[IpV4Addr,str]).get_json_schema())
    jsonschema.validate(
        {'7':'b'},codec(dict[Literal[AnIntEnum.a],str]).get_json_schema())
    jsonschema.validate(
        {'7':'b'},codec(dict[AnIntEnum,str]).get_json_schema())
    jsonschema.validate(
        {'k': 1, 'v': 'fred'},codec(MixedEnum).get_json_schema())
    try:
        jsonschema.validate(
        {'k': 1, 'v': 'jock'},codec(MixedEnum).get_json_schema())
    except Exception as e:
        Assert(readable_repr(e))=="{'k': 1, 'v': 'jock'} is not valid under any of the given schemas\n\nFailed validating 'oneOf' in schema:\n    {'oneOf': [{'$ref': '#/definitions/MixedEnum.a'},\n               {'$ref': '#/definitions/MixedEnum.b'}]}\n\nOn instance:\n    {'k': 1, 'v': 'jock'}"
    else:
        assert False
    pass

# internal: codecs' encode()s must verify correct type passed in, otherwise
# UnionCodec encode try-each algorithm is invalid
try:
    x=(codec(int)
       .encode('fred'))  # type: ignore
except Exception as e:
    Assert("'fred' is not a <class 'int'>").isIn(str(e))
else:
    assert False, x
    pass
try:
    x=(codec(list[int])
       .encode('fred'))  # type: ignore
except Exception as e:
    Assert("'fred' is not a list").isIn(str(e))
else:
    assert False, x
    pass
try:
    x=(codec(list)
       .encode('fred'))  # type: ignore
except Exception as e:
    Assert("'fred' is not a list").isIn(str(e))
else:
    assert False, x
    pass
try:
    x=(codec(set[int])
       .encode('fred'))  # type: ignore
except Exception as e:
    Assert("'fred' is not a set").isIn(str(e))
else:
    assert False, x
    pass
try:
    x=(codec(set)
       .encode('fred'))  # type: ignore
except Exception as e:
    Assert("'fred' is not a set").isIn(str(e))
else:
    assert False, x
    pass
try:
    x=(codec(frozenset[int])
       .encode('fred'))  # type: ignore
except Exception as e:
    Assert("'fred' is not a frozenset").isIn(str(e))
else:
    assert False, x
    pass
try:
    x=(codec(frozenset)
       .encode('fred'))  # type: ignore
except Exception as e:
    Assert("'fred' is not a frozenset").isIn(str(e))
else:
    assert False, x
    pass
try:
    x=(codec(tuple[int])
       .encode('fred'))  # type: ignore
except Exception as e:
    Assert("'fred' is not a tuple").isIn(str(e))
else:
    assert False, x
    pass


# ensure JsonType (Union) selects correct codec to encode dict
@dataclass
class Y:
    x: JsonType
    pass

Assert(codec(Y).encode(Y({ 'z': 'fred' })))=={'x':{'z':'fred'}}
Assert(codec(Y).decode({'x':{'z':'fred'}}))==Y({ 'z': 'fred' })
Assert(codec(Y).get_json_schema())=={
    '$ref': '#/definitions/Y',
    '$id': 'https://example.com/address.schema.json',
    '$schema': 'https://json-schema.org/draft/2020-12/schema',
    'definitions': {
        'dict': {'type': 'object'},
        'None|bool|dict|list|float|str': {
            'oneOf': [{'type': 'null'},
                      {'type': 'boolean'},
                      {'$ref': '#/definitions/dict'},
                      {'type': 'array'},
                      {'type': 'number'},
                      {'type': 'string'}]},
        'Y': {'description': 'Y', 'type': 'object', 'properties': {
            'x': {'$ref': '#/definitions/None|bool|dict|list|float|str'}}}}}


# type hint strings are supported, allowing forward-decls
@dataclass
class ShirtSize:
    size: 'SizeCode'
    pass

Small=Literal['S']
Large=Literal['L']
SizeCode=Small|Large

Assert(codec(ShirtSize).decode(
    {
        'size': 'S',
    }
))==ShirtSize('S')


# coverage of class decode initialisation failure
class Freddy:
    x: str
    def __init__(self, x:str):
        if x=='jock':
            raise Exception('jock forbidden')
        pass
    pass

try:
    codec(Freddy).decode({'x':'jock'})
except Exception as e:
    Assert(readable_repr(e))=="Failed to decode {'x': 'jock'} to a <class '__main__.Freddy'> because\nfailed to decode {'x': 'jock'} as a <class '__main__.Freddy'> because\nfailed to init <class '__main__.Freddy'> with keyword arguments {'x': 'jock'} because\njock forbidden."
else:
    assert False
    pass

# multiple defaults values, including list type, can omit any or all defaulted attributes
# use kw_only to allow any ordering of attributes in class definition
# it seems clever but I don't think jsonschema or typescript generation works properly
# (typescript and jsonschema will insist on the default fields being specified). Note
# encoding from python will always include the value even if it came from default.
@dataclass(kw_only=True)
class Person:
    first_name: str
    middle_names: list[str] = field(default_factory=list)
    last_name: str
    phobias: list[str] = field(default_factory=list)
    pass

Assert(codec(Person).decode({'first_name':'fred','last_name':'jones'}))==Person(first_name='fred',last_name='jones')
Assert(codec(Person).decode({'first_name':'fred','phobias':['spiders'],'last_name':'jones'}))==Person(first_name='fred',last_name='jones',phobias=['spiders'])
Assert(codec(Person).decode({'first_name':'fred','middle_names':['arachnid'],'last_name':'jones'}))==Person(first_name='fred',last_name='jones',middle_names=['arachnid'])


# non-defaulted "optional" attribute (of type X|None) must still appear in json (with value null)
@dataclass
class Opt:
    x: str|None
    pass

Assert(codec(Opt).decode({'x':None}))==Opt(x=None)
try:
    codec(Opt).decode({})
except Exception as e:
    Assert(readable_repr(e)).contains("Failed to decode {} to a <class '__main__.Opt'> because\nfailed to decode {} as a <class '__main__.Opt'> because\nfailed to init <class '__main__.Opt'> with keyword arguments {} because\nOpt.__init__() missing 1 required positional argument: 'x'.")
else:
    assert False
    pass


# specialisation based on descriminator
@dataclass
class Court:
    width:Metres
    length:Metres
    pass

@dataclass
class NetballCourt(Court):
    game:Literal['netball'] = 'netball'
    pass

@dataclass
class BasketballCourt(Court):
    game:Literal['basketball'] = 'basketball'
    pass

court_codec=codec(NetballCourt|BasketballCourt|Court)
Assert(court_codec.decode({'game':'netball', 'width':8, 'length': 10})).isInstanceOf(NetballCourt)
Assert(court_codec.decode({'game':'basketball', 'width':8, 'length': 10})).isInstanceOf(BasketballCourt)
Assert(court_codec.decode({'game':'badminton', 'width':8, 'length': 10})).isInstanceOf(Court)
Assert(court_codec.encode(NetballCourt(width=Metres(8),length=Metres(10)))=={'game':'netball', 'width':8, 'length': 10})
Assert(court_codec.encode(BasketballCourt(width=Metres(8),length=Metres(10)))=={'game':'basketball', 'width':8, 'length': 10})


# generic class codecs are supported, for example a messages might
# carry generic payloads:

Payload=TypeVar('Payload')

@dataclass
class SetMsg(Generic[Payload]):
    msg_type: Literal['set_new_value']
    new_value: Payload
    pass

SetSurnameMsg=SetMsg[Surname]

Assert(codec(SetSurnameMsg).decode({'msg_type':'set_new_value','new_value':'knox'}))==SetSurnameMsg(msg_type='set_new_value',new_value=Surname('knox'))

@dataclass
class SetMultiMsg(Generic[Payload]):
    msg_type: Literal['set_new_values']
    new_values: list[Payload]
    pass

SetSurnamesMsg=SetMultiMsg[Surname]

Assert(codec(SetSurnamesMsg).decode({'msg_type':'set_new_values','new_values':['knox','garden']}))==SetSurnamesMsg(msg_type='set_new_values',new_values=[Surname('knox'),Surname('garden')])


# codec can generate a typescript "cast" ("as-a") and "type guard" ("is-a") matching its
# json encoding. Non-class codecs generate inline typescript source code, see
# codec.get_typescript_asa() and codec.get_typescript_isa(). For classes, codec
# also generates functions in corresponding namespace, for example:

typescript_namespace=TypeScriptNamespace({})

codec(O).ensure_typescript_defs(typescript_namespace)

# ... get_formatted_defs() generates the typescript source code:
Assert(typescript_namespace.get_formatted_defs())==TypeScriptSourceCode(
    '''\
enum O {
    a = "fred",
    b = 7
};

function asInstanceOfO(v: any): O
{
    const r=_asInstanceOfO.f(v);
    r.applyDefaults();
    return v as O;
}
function isInstanceOfO(v:any): v is string
{
    const r:false|xju.json_codec.ApplyDefaults=_isInstanceOfO(v);
    return r&&r.applyDefaults();
}
const _asInstanceOfO = xju.json_codec.asInstanceOfUnion([
        xju.json_codec.asInstanceOfLiteral(O.a),
    xju.json_codec.asInstanceOfLiteral(O.b)
]);
const _isInstanceOfO = xju.json_codec.isInstanceOfUnion([
        xju.json_codec.isInstanceOfLiteral(O.a),
    xju.json_codec.isInstanceOfLiteral(O.b)
]);
const _asKeyOfO = xju.json_codec.asKeyOfUnion([
        xju.json_codec.asKeyOfLiteral(O.a),
    xju.json_codec.asKeyOfLiteral(O.b)
]);
const _isKeyOfO = xju.json_codec.isKeyOfUnion([
        xju.json_codec.isKeyOfLiteral(O.a),
    xju.json_codec.isKeyOfLiteral(O.b)
]);''')

# https://github.com/urnest/urnest/issues/2
ArgType = TypeVar("ArgType")
def c1(t: Type[ArgType], g: Callable[[JsonType],None])->Callable[[ArgType],None]:
    c=codec(t)
    def result(x: ArgType) -> None:
        g(c.encode(x))
        pass
    return result

c1(int, lambda j: None)(7)

# aliases
AY = int|str
AX = AY
ac=codec(AX)
a1 = (ac.encode(7),
      ac.encode("fred"))
ra1:AX = ac.decode(7)
ra1 = ac.decode("fred")


# note on mypy handling of generic type used without params:
Q=TypeVar('Q')
class QQ(Generic[Q]):
    q: Q
q:QQ=QQ() # is this QQ[Any]?
q.q=3  # yes, no mypy error here


# should not be any errors, because codec(dict) should become
# Codec(dict[str, JsonType])
d = codec(dict).decode({'fred':5, 'jock': 'nine'})
dd: JsonType = d['fred']


# should not be any errors... hmm can't really do until have a bounded
# typevar with checking:
#a: list[tuple[Encodable, Encodable]] = [
#    (int, str | None)
#]
#b = [(codec(k), codec(v)) for k, v in a]


# StrEnum, IntEnum
class AnStrEnum(StrEnum):
    a = 'fred'
    b = auto()

#... member codecs...
Assert(codec(Literal[AnStrEnum.b]).decode('b'))==AnStrEnum.b
Assert(codec(Literal[AnStrEnum.a]).decode('fred'))==AnStrEnum.a
Assert(codec(Literal[AnStrEnum.a]).encode(AnStrEnum.a))=='fred'
try:
    x=codec(Literal[AnStrEnum.a]).decode(7)
except Exception as e:
    Assert(readable_repr(e))=="Failed to decode 7 to a typing.Literal[<AnStrEnum.a: 'fred'>] because\nfailed to decode 7 as AnStrEnum.a because\n7 (of type <class 'int'>) is not a <class 'str'>."
else:
    assert False, x
try:
    x=codec(Literal[AnStrEnum.a]).decode('jock')
except Exception as e:
    Assert(readable_repr(e))=="Failed to decode jock to a typing.Literal[<AnStrEnum.a: 'fred'>] because\nfailed to decode 'jock' as AnStrEnum.a because\n'jock' is not 'fred'."
else:
    assert False, x

#... member codecs...
Assert(codec(Literal[AnIntEnum.a]).decode(7))==AnIntEnum.a
Assert(codec(Literal[AnIntEnum.b]).decode(8))==AnIntEnum.b
Assert(codec(Literal[AnIntEnum.a]).encode(AnIntEnum.a))==7
try:
    x=codec(Literal[AnIntEnum.a]).decode(8)
except Exception as e:
    Assert(readable_repr(e))=='Failed to decode 8 to a typing.Literal[<AnIntEnum.a: 7>] because\nfailed to decode 8 as AnIntEnum.a because\n8 is not 7.'
else:
    assert False, x
try:
    x=codec(Literal[AnIntEnum.a]).decode('jock')
except Exception as e:
    Assert(readable_repr(e))=="Failed to decode jock to a typing.Literal[<AnIntEnum.a: 7>] because\nfailed to decode 'jock' as AnIntEnum.a because\n'jock' (of type <class 'str'>) is not a <class 'int'>."
else:
    assert False, x
try:
    x=(codec(Literal[AnIntEnum.a])
       .encode(AnIntEnum.b))  # type: ignore
except Exception as e:
    Assert(readable_repr(e))=="Failed to encode <AnIntEnum.b: 8> as a AnIntEnum.a because\n8 != 7."
else:
    assert False, x

# invalid dict key encoded value
try:
    x=codec(dict[tuple[int,str],str])  # type: ignore  # json_codec plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e)).contains('tuple[int,str] is not valid as a json object key')
else:
    assert False
    pass

# Final
class FinalT:
    v: Final[str]
    def __init__(self, v: str) -> None:
        self.v=v
        pass
    def __eq__(self, x) -> bool:
        return isinstance(x, FinalT) and x.v==self.v
    pass

Assert(codec(FinalT).encode(FinalT('fred')))=={"v":"fred"}
Assert(codec(FinalT).decode({"v":"fred"}))==FinalT('fred')

codec(dict[IpV4Addr,int]).ensure_typescript_defs(typescript_namespace)

Assert(codec(dict[Colour,int]).encode({Colour("red"):1}))=={"red":1}
Assert(codec(dict[Milligrams,int]).encode({Milligrams(20.5):2}))=={20.5:2}
Assert(codec(dict[Votes,int]).encode({Votes(8):9}))=={8:9}
Assert(codec(dict[Enabled,int]).encode({Enabled(True):2,Enabled(False):1}))=={True:2,False:1}

Assert(codec(dict[Colour,int]).decode({"red":1}))=={Colour("red"):1}
Assert(codec(dict[Milligrams,int]).decode({20.5:2}))=={Milligrams(20.5):2}
Assert(codec(dict[Votes,int]).decode({8:9}))=={Votes(8):9}
Assert(codec(dict[Enabled,int]).decode({True:2,False:1}))=={Enabled(True):2,Enabled(False):1}

codec(dict[Colour,int]).ensure_typescript_defs(typescript_namespace)
codec(dict[Milligrams,int]).ensure_typescript_defs(typescript_namespace)
codec(dict[Votes,int]).ensure_typescript_defs(typescript_namespace)
codec(dict[Enabled,int]).ensure_typescript_defs(typescript_namespace)

# dont_encode_attr exception
try:
    dont_encode_attr(DontEncode, PythonAttrName("cll"))
except Exception as e:
    Assert(readable_repr(e))=="Failed to don't encode <class '__main__.DontEncode'>'s cll attribute to json because\n<class '__main__.DontEncode'> apparently has no declared 'cll' attribute."
else:
    assert False
    pass

# recursive types
@dataclass
class And:
    a: tuple["B", "B", list["B"]]
    pass

@dataclass
class Or:
    o: tuple["B", "B", list["B"]]
    pass

B = Union[str, And, Or]

Assert(codec(B).encode(And( (Or( ('1','2',[]) ),'3',[And( ('4','6',[]) )]) ))) == {
    "a": [{"o": ['1','2',[]]},'3', [{ "a": ['4','6',[]] }]]
}

Assert(codec(B).decode({
    "a": [{"o": ['1','2',[]]},'3', [{ "a": ['4','6',[]] }]]
})) == And( (Or( ('1','2',[]) ),'3',[And( ('4','6',[]) )]) )

Assert(codec(B).get_json_schema())=={
    '$ref': '#/definitions/str|And|Or',
    '$id': 'https://example.com/address.schema.json',
    '$schema': 'https://json-schema.org/draft/2020-12/schema',
    'definitions': {
        'list[str|And|Or]': {
            'type': 'array',
            'items': {'$ref': '#/definitions/str|And|Or'}},
        'tuple[str|And|Or,str|And|Or,list[str|And|Or]]': {
            'type': 'array',
            'prefixItems': [{'$ref': '#/definitions/str|And|Or'},
                            {'$ref': '#/definitions/str|And|Or'},
                            {'$ref': '#/definitions/list[str|And|Or]'}]},
        'And': {'description': 'And', 'type': 'object', 'properties': {
            'a': {'$ref': '#/definitions/tuple[str|And|Or,str|And|Or,list[str|And|Or]]'}}},
        'Or': {'description': 'Or', 'type': 'object', 'properties': {
            'o': {'$ref': '#/definitions/tuple[str|And|Or,str|And|Or,list[str|And|Or]]'}}},
        'str|And|Or': {'oneOf': [
            {'type': 'string'},
            {'$ref': '#/definitions/And'},
            {'$ref': '#/definitions/Or'}]}}}

try:
    import jsonschema # type: ignore
except:
    print('WARNING: skipped json_codec json_schema tests because jsonschema not importable',
          file=sys.stderr)
else:
    jsonschema.validate(codec(B).encode(And( (Or( ('1','2',[]) ),'3',[And( ('4','6',[]) )]) )),
                        codec(B).get_json_schema())
    pass

# coverage of nested Self
@dataclass
class SList:
    @dataclass
    class Tail:
        val: int
        next: Self | None
    val: int
    tail: Tail | None
    pass

Assert(codec(SList).encode(SList(3,SList.Tail(5,None))))=={'val': 3, 'tail': {'val': 5, 'next': None}}

@dataclass
class TSList:
    @dataclass
    class Tail(Generic[Q]):
        val: Q
        next: Self | None
    val: int
    tail: Tail[int] | None
    pass

Assert(codec(TSList).encode(TSList(3,TSList.Tail(5,None))))=={'val': 3, 'tail': {'val': 5, 'next': None}}

Assert(indent(4, TypeScriptSourceCode('')))==''


class DV1:
    x: int = 2
    y: str
    pass

Assert(get_default_value(DV1, "x"))==(2,)
Assert(get_default_value(DV1, "y"))==None

@dataclass
class DV2:
    x: int = field(default=2)
    pass

Assert(get_default_value(DV2, "x"))==(2,)

def fred()->Literal["fred"]:
    return "fred"

@dataclass
class DV3:
    y: int
    x: str = field(default_factory=fred)
    pass

Assert(get_default_value(DV3, "x"))==("fred",)
Assert(get_default_value(DV3, "y"))==None

class LiteralO(Enum):
    a='fred'
    b=(1,2,3)
    pass

try:
    codec(LiteralO).encode(3.2)  # type: ignore  # json_codec plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e)).contains('3.2 is not an instance of class LiteralO (it is of class float).')
else:
    assert False
    pass

try:
    codec(LiteralO).decode(3.2)  # type: ignore  # json_codec plugin correctly rejects
except Exception as e:
    Assert(readable_repr(e)).contains("Failed to decode 3.2 to a <enum 'LiteralO'> because")
else:
    assert False
    pass


# generic custom codec

class ShapeOfT(Protocol):
    x: str

@dataclass(kw_only=True)
class G[C, T: ShapeOfT]:
    c: type[C]
    v: T

    @staticmethod
    def get_codec(type_var_map:dict[TypeVar,Any]) -> CodecProto:
        assert type_var_map is not None
        return codec(type_var_map[G.__parameters__[1]].__annotations__['x'])  # type: ignore

    # xju.json_codec.CustomGenericClassCodec:
    @staticmethod
    def xju_json_codec_encode_generic(
            x:"G[C,T]",
            type_var_map:dict[TypeVar,type]) -> JsonType:
        """only encodes the T.x attribute"""
        return G.get_codec(type_var_map).encode(x.v.x)
    @staticmethod
    def xju_json_codec_decode_generic(
            x:JsonType,
            type_var_map:dict[TypeVar,type]) -> "G[C,T]":
        v_x=G.get_codec(type_var_map).decode(x)
        return G(c=type_var_map[G.__parameters__[0]],  # type: ignore
                 v=type_var_map[G.__parameters__[1]](x=v_x))  # type: ignore
    @staticmethod
    def xju_json_codec_get_json_schema_generic(
            definitions:dict[str,dict],
            type_var_map:dict[TypeVar,type]) -> dict:
        '''return json schema for T'''
        '''- may add any supporting definitions to definitions'''
        return G.get_codec(type_var_map).get_json_schema()
    @staticmethod
    def xju_json_codec_get_typescript_type_generic(
            type_var_map:dict[TypeVar,type]) -> TypeScriptSourceCode:
        kt=f"typeof {G.__parameters__[0]}"
        vt=f"{G.__parameters__[1]}"
        return TypeScriptSourceCode(f"string /* G<{kt},{vt} */");
    @staticmethod
    def xju_json_codec_5_get_typescript_isa_generic(
            namespace: TypeScriptNamespace,
            type_var_map:dict[TypeVar,type]) -> TypeScriptSourceCode:
        '''return typescript source that evaluates to a xju.json_codec.IsInstance
           - may add any supporting definitions to namespace, e.g. type for T itself'''
        return TypeScriptSourceCode("xju.json_codec.isInstanceOfString;");
    @staticmethod
    def xju_json_codec_5_get_typescript_asa_generic(
            namespace: TypeScriptNamespace,
            type_var_map:dict[TypeVar,type]) -> TypeScriptSourceCode:
        '''return typescript source code that verifies {expression} with defaults applied would be a T and returns xju.json_codec.ApplyDefaults that would apply defaults, throwing an Error if {expression} is not valid as a T'''
        '''- may add any supporting definitions to namespace, e.g. type for T itself'''
        kt=f"typeof {G.__parameters__[0]}"
        vt=f"{G.__parameters__[1]}"
        return TypeScriptSourceCode(f"xju.json_codec.asInstanceOfString('G<{kt},{vt}>'");
    pass

assert issubclass(G, CustomGenericClassCodec)

@dataclass(kw_only=True)
class GT:
    x: str
    pass


Assert(codec(G[int,GT]).decode('fred'))==G(c=int, v=GT(x='fred'))  # type: ignore
Assert(codec(G[int,GT]).encode(G(c=int, v=GT(x='fred'))))=='fred'  # type: ignore
Assert(codec(G[int,GT]).get_json_schema())=={'type': 'string', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema', 'definitions': {}} # type: ignore
Assert(codec(tuple[G[int,GT]]).get_json_schema())=={'$ref': '#/definitions/tuple[G]', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema', 'definitions': {'tuple[G]': {'type': 'array', 'prefixItems': [{'type': 'string', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema', 'definitions': {}}]}}} # type: ignore

try:
    codec(G[int,GT]).decode({})  # type: ignore
except Exception as e:
    Assert(readable_repr(e)).contains("{} (of type <class 'dict'>) is not a <class 'str'>.")
else:
    assert False
try:
    codec(G[int,GT]).encode(7)  # type: ignore
except Exception as e:
    Assert(readable_repr(e)).contains("Failed to encode 7 as a <class '__main__.G'> because\n7 (of type <class 'int'>) is not a <class '__main__.G'>.")
else:
    assert False
    
# generic custom codec, usable as object key

@dataclass(kw_only=True)
class GK[C, T: ShapeOfT]:
    c: type[C]
    v: T

    @staticmethod
    def get_codec(type_var_map:dict[TypeVar,Any]) -> CodecProto:
        assert type_var_map is not None
        return codec(type_var_map[GK.__parameters__[1]].__annotations__['x'])  # type: ignore

    # xju.json_codec.CustomGenericClassCodec:
    @staticmethod
    def xju_json_codec_encode_generic(
            x:"GK[C,T]",
            type_var_map:dict[TypeVar,type]) -> JsonType:
        """only encodes the T.x attribute"""
        return GK.get_codec(type_var_map).encode(x.v.x)
    @staticmethod
    def xju_json_codec_decode_generic(
            x:JsonType,
            type_var_map:dict[TypeVar,type]) -> "GK[C,T]":
        v_x=GK.get_codec(type_var_map).decode(x)
        return GK(c=type_var_map[GK.__parameters__[0]],  # type: ignore
                  v=type_var_map[GK.__parameters__[1]](x=v_x))  # type: ignore
    @staticmethod
    def xju_json_codec_get_json_schema_generic(
            definitions:dict[str,dict],
            type_var_map:dict[TypeVar,type]) -> dict:
        '''return json schema for T'''
        '''- may add any supporting definitions to definitions'''
        return GK.get_codec(type_var_map).get_json_schema()
    @staticmethod
    def xju_json_codec_get_typescript_type_generic(
            type_var_map:dict[TypeVar,type]) -> TypeScriptSourceCode:
        kt=f"typeof {G.__parameters__[0]}"
        vt=f"{G.__parameters__[1]}"
        return TypeScriptSourceCode(f"string /* GK<{kt},{vt}> */");
    @staticmethod
    def xju_json_codec_5_get_typescript_isa_generic(
            namespace: TypeScriptNamespace,
            type_var_map:dict[TypeVar,type]) -> TypeScriptSourceCode:
        '''return typescript source that evaluates to a xju.json_codec.IsInstance
           - may add any supporting definitions to namespace, e.g. type for T itself'''
        return TypeScriptSourceCode("xju.json_codec.isInstanceOfString;");
    @staticmethod
    def xju_json_codec_5_get_typescript_asa_generic(
            namespace: TypeScriptNamespace,
            type_var_map:dict[TypeVar,type]) -> TypeScriptSourceCode:
        '''return typescript source code that verifies {expression} with defaults applied would be a T and returns xju.json_codec.ApplyDefaults that would apply defaults, throwing an Error if {expression} is not valid as a T'''
        '''- may add any supporting definitions to namespace, e.g. type for T itself'''
        kt=f"typeof {GK.__parameters__[0]}"
        vt=f"{GK.__parameters__[1]}"
        return TypeScriptSourceCode(f"xju.json_codec.asInstanceOfString('GK<{kt},{vt}>'");
    @staticmethod
    def xju_json_codec_get_object_key_json_schema_generic(
            definitions:dict[str,dict],
            type_var_map:dict[TypeVar,type]) -> dict:
        '''return json schema for T when used as an object key
           - may add any supporting definitions to definitions'''
        return GK.get_codec(type_var_map).get_json_schema()
    @staticmethod
    def xju_json_codec_typescript_key_type_generic(type_var_map:dict[TypeVar,type])-> Literal['String']:
        return 'String'

    @staticmethod
    def xju_json_codec_5_get_typescript_isa_key_generic(
            namespace: TypeScriptNamespace,
            type_var_map:dict[TypeVar,type]) -> TypeScriptSourceCode:
        '''return typescript source code that evaluates to a xju.json_codec.IsKey
           - may add any supporting definitions to namespace, e.g. type for T itself'''
        assert False  #pragma NO COVER
        return TypeScriptSourceCode('')
    @staticmethod
    def xju_json_codec_5_get_typescript_asa_key_generic(
            namespace: TypeScriptNamespace,
            type_var_map:dict[TypeVar,type]) -> TypeScriptSourceCode:
        '''return typescript source code that evaluates to a xju.json_codec.AsKey
           - may add any supporting definitions to namespace, e.g. type for T itself'''
        assert False  #pragma NO COVER
        return TypeScriptSourceCode('')
    pass

assert issubclass(GK, CustomStringKeyGenericClassCodec)
Assert(codec(GK[int,GT]).decode('fred'))==GK(c=int, v=GT(x='fred'))  # type: ignore
Assert(codec(GK[int,GT]).encode(GK(c=int, v=GT(x='fred'))))=='fred'  # type: ignore
Assert(codec(GK[int,GT]).get_json_schema())=={'type': 'string', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema', 'definitions': {}} # type: ignore
Assert(codec(tuple[GK[int,GT]]).get_json_schema())=={'$ref': '#/definitions/tuple[GK]', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema', 'definitions': {'tuple[GK]': {'type': 'array', 'prefixItems': [{'type': 'string', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema', 'definitions': {}}]}}} # type: ignore
Assert(codec(dict[GK[int,GT],bool]).get_json_schema())=={'$ref': '#/definitions/dict[GK,bool]', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema', 'definitions': {'dict[GK,bool]': {'type': 'object', 'additionalProperties': {'type': 'boolean'}}}} # type: ignore
Assert(codec(tuple[GK[int,GT]]).get_json_schema())=={'$ref': '#/definitions/tuple[GK]', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema', 'definitions': {'tuple[GK]': {'type': 'array', 'prefixItems': [{'type': 'string', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema', 'definitions': {}}]}}} # type: ignore

try:
    codec(GK[int,GT]).decode({})  # type: ignore
except Exception as e:
    Assert(readable_repr(e)).contains("{} (of type <class 'dict'>) is not a <class 'str'>.")
else:
    assert False
try:
    codec(GK[int,GT]).encode(7)  # type: ignore
except Exception as e:
    Assert(readable_repr(e)).contains("Failed to encode 7 as a <class '__main__.GK'> because\n7 (of type <class 'int'>) is not a <class '__main__.GK'>.")
else:
    assert False

# coverage
try:
    codec(IpV4Addr).encode('nine')  # type: ignore
except Exception as e:
    Assert(readable_repr(e)).contains("'nine' (of type <class 'str'>) is not a <class '__main__.IpV4Addr'>.")
else:
    assert False
    pass
