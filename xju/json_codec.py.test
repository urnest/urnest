#!/usr/bin/env python3

# Copyright (c) 2022 Trevor Taylor
# coding: utf-8
# 
# Permission to use, copy, modify, and/or distribute this software for
# any purpose with or without fee is hereby granted, provided that all
# copyright notices and this permission notice appear in all copies.
# 
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
#
from sys import path
from os.path import dirname
if path[0]==dirname(__file__): path.pop(0)

from xju.json_codec import Codec, JsonType, AnyJsonCodec, SelfCodec

from typing import cast, Type, Literal, Any, Self
from types import NoneType
from dataclasses import dataclass
import re
import sys

from xju.assert_ import Assert
import xju.newtype
from xju.xn import readable_repr

x:Any


# int,str,bool,float,None map directly

Assert(Codec[int](int).decode(3))==3
Assert(Codec[str](str).decode('fred'))=='fred'
Assert(Codec[bool](bool).decode(True))==True
Assert(Codec[float](float).decode(5.5))==5.5
Assert(Codec[float](float).decode(5))==5

Assert(Codec[int](int).encode(3))==3
Assert(Codec[str](str).encode('fred'))=='fred'
Assert(Codec[bool](bool).encode(True))==True
Assert(Codec[float](float).encode(5.5))==5.5
Assert(Codec[float](float).encode(5))==5

# note None is a bit weird, sometimes it acts as as a type, others not
Assert(Codec[None](type(None)).decode(None))==None
Assert(Codec[None](type(None)).encode(None))==None


# list maps to list...
Assert(Codec[list](list).decode([5, 'fred']))==[5, 'fred']
Assert(Codec[list](list).encode([5, 'fred']))==[5, 'fred']

# ... but must be given a list
try:
    x=Codec[list](list).decode(8)
except Exception as e:
    Assert("8 is not a list").isIn(str(e))
else:
    assert False, x
    pass
# ... note element types are not checked (it is assumed
# result will be given to json.dumps, which will fail), e.g.
# we can happily put print, which has no mapping to a json type,
# into a non-type-adorned list and encode that list:
Assert(Codec[list](list).encode([print]))==[print]


# type-adorned list maps to list...
Assert(Codec[list[int]](list[int]).decode([5, 6]))==[5, 6]
Assert(Codec[list[int]](list[int]).encode([5, 6]))==[5, 6]

# ... but must be given a list...
try:
    x=Codec[list[int]](list[int]).decode(8)
except Exception as e:
    Assert("8 is not a list").isIn(str(e))
else:
    assert False, x
    pass

# ... and all values must have correct type
try:        
    x=Codec[list[int]](list[int]).decode([5, 'fred'])
except Exception as e:
    Assert("'fred' (of type <class 'str'>) is not a <class 'int'>").isIn(str(e))
else:
    assert False, x
    pass


# tuple encodes as list (note, tuples without specific element types are disallowed)

#mypy 1.0.0 bug:
#c=Codec[tuple[int,str]](tuple[int,str])
# ... says:
# /home/xju/urnest/xju/json_codec.py.test:43: error: Argument 1 to "Codec" has incompatible type "Type[Tuple[Any, ...]]"; expected "Type[Tuple[int, str]]"  [arg-type]
# ... but there are so many tuple-related bugs on github it's not really surprising

tuple_codec=Codec[tuple[int,str]](cast(Type[tuple[int,str]],tuple[int,str]))  #mypy 1.0.0 bug
Assert(tuple_codec.decode([5, 'fred']))==(5, 'fred')
Assert(tuple_codec.encode((5, 'fred')))==[5, 'fred']

# for list to decode as tuple, it must be a list in the first place...
try:        
    x=tuple_codec.decode({'x':6, 'y':8})
except Exception as e:
    Assert("{'x': 6, 'y': 8} is not a list").isIn(str(e))
else:
    assert False, x
    pass

# ... it must have expected number of elements each of the expected type...
try:        
    x=tuple_codec.decode([5, 6, 7])
except Exception as e:
    Assert("[5, 6, 7] does not have 2 items (it has 3 items)").isIn(str(e))
else:
    assert False, x
    pass

# ... each element must have correct type...
try:
    x=tuple_codec.decode([5, 6])
except Exception as e:
    Assert("6 (of type <class 'int'>) is not a <class 'str'>").isIn(str(e))
else:
    assert False, x
    pass

# encoding also rejects wrong number of elements, but this would be
# rejected by type checker anyway
try:
    x=tuple_codec.encode((5, 6, 7))  # type: ignore
except Exception as e:
    Assert("(5, 6, 7) does not have 2 items (it has 3 items)").isIn(str(e))
else:
    assert False, x
    pass


# dict with no type hints allows any keys with any value types (key must be string)
Assert(Codec[dict](dict).decode({'fred':5, 'jock': 'nine'}))=={'fred':5, 'jock':'nine'}
Assert(Codec[dict](dict).encode({'fred':5, 'jock': 'nine'}))=={'fred':5, 'jock':'nine'}

# dict with specific value type...
Assert(Codec[dict[str,int]](dict[str,int]).decode({'fred':5, 'jock': 9}))=={'fred':5, 'jock':9}
Assert(Codec[dict[str,int]](dict[str,int]).encode({'fred':5, 'jock': 9}))=={'fred':5, 'jock':9}

# ... must be given a dict...
try:
    x=Codec[dict](dict).decode(7)
except Exception as e:
    Assert("7 is not a dict").isIn(str(e))
else:
    assert False, x
    pass
try:
    x=Codec[dict[str,int]](dict[str,int]).decode(7)
except Exception as e:
    Assert("7 is not a dict").isIn(str(e))
else:
    assert False, x
    pass

# ... expects all elements to have that value type incorrect dict value type
try:
    x=Codec[dict[str,int]](dict[str,int]).decode({'jock': 'fred'})
except Exception as e:
    Assert("'fred' (of type <class 'str'>) is not a <class 'int'>").isIn(str(e))
else:
    assert False, x
    pass

# dict keys must be strings...
try:
    x=Codec[dict](dict).encode({6: 'fred'})
except Exception as e:
    Assert(str(e)).matches("6 is not a <class 'str'>")
else:
    assert False, x
    pass
try:
    x=Codec[dict[int,int]](dict[int,int]).encode({7:5}) # type: ignore
except Exception as e:
    Assert("produced non-str 7 from dict key 7").isIn(str(e))
else:
    assert False, x
    pass

# ... must be given a dict...
try:
    x=Codec[dict](dict).encode(7) # type: ignore
except Exception as e:
    Assert("7 is not a dict").isIn(str(e))
else:
    assert False, x
    pass
try:
    x=Codec[dict[str,int]](dict[str,int]).encode(7) # type: ignore
except Exception as e:
    Assert("7 is not a dict").isIn(str(e))
else:
    assert False, x
    pass

#xju.newtype.Int support
class AgeInYearsTag:pass
class AgeInYears(xju.newtype.Int[AgeInYearsTag]):pass

Assert(Codec[AgeInYears](AgeInYears).decode(3))==AgeInYears(3)
Assert(Codec[AgeInYears](AgeInYears).encode(AgeInYears(3)))==3

try:
    x=Codec[AgeInYears](AgeInYears).decode('fred')
except Exception as e:
    Assert("'fred' (of type <class 'str'>) is not an int").isIn(str(e))
else:
    assert False, x
    pass

try:        
    x=Codec[AgeInYears](AgeInYears).encode(8) # type: ignore
except Exception as e:
    Assert("8 is not a <class '__main__.AgeInYears'>").isIn(str(e))
else:
    assert False, x
    pass

#xju.newtype.Float support
class MetresTag:pass
class Metres(xju.newtype.Float[MetresTag]):pass

Assert(Codec[Metres](Metres).decode(3.8))==Metres(3.8)
Assert(Codec[Metres](Metres).encode(Metres(3.8)))==3.8
Assert(Codec[Metres](Metres).decode(3))==Metres(3)
Assert(Codec[Metres](Metres).encode(Metres(3)))==3

try:
    x=Codec[Metres](Metres).decode('fred')
except Exception as e:
    Assert("'fred' (of type <class 'str'>) is not a float (or an int)").isIn(str(e))
else:
    assert False, x
    pass

try:
    x=Codec[Metres](Metres).encode('fred') # type: ignore
except Exception as e:
    Assert("'fred' is not a <class '__main__.Metres'>").isIn(str(e))
else:
    assert False, x
    pass

#xju.newtype.Str support
class SurnameTag:pass
class Surname(xju.newtype.Str[SurnameTag]):pass

Assert(Codec[Surname](Surname).decode('Ang'))==Surname('Ang')
Assert(Codec[Surname](Surname).encode(Surname('Ang')))=='Ang'

try:
    x=Codec[Surname](Surname).decode(17)
except Exception as e:
    Assert("17 (of type <class 'int'>) is not an str").isIn(str(e))
else:
    assert False, x
    pass

try:
    x=Codec[Surname](Surname).encode(17) # type: ignore
except Exception as e:
    Assert("17 is not a <class '__main__.Surname'>").isIn(str(e))
else:
    assert False, x
    pass

# type unions, e.g. str|int match either type

#mypy 1.0.0 bug
#union_codec=Codec[str|int](str|int)
# says:
#  error: Argument 1 to "Codec" has incompatible type "UnionType"; expected "Union[Type[str], Type[int]]"  [arg-type]

union_codec=Codec[str|int](cast(Type[str|int],str|int))
Assert(union_codec.decode('fred'))=='fred'
Assert(union_codec.decode(9))==9
Assert(union_codec.encode('fred'))=='fred'
Assert(union_codec.encode(9))==9

#incorrect dict value type
try:
    x=union_codec.decode(5.7)
except Exception as e:
    Assert(str(e)).matches("failed to decode 5.7 to a str | int because.*failed to decode as <class 'str'> because 5.7 (of type <class 'float'>) is not a <class 'str'> and failed to decode as <class 'int'> because 5.7 (of type <class 'float'>) is not a <class 'int'>")
else:
    assert False, x
    pass


# class (object) support:
#   encoding is dictionary containing each objct attribute (except that string literal
#   attributes are treated specially, see string literal attributes below)
class StreetTag:pass
class Street(xju.newtype.Str[StreetTag]):pass

class SuburbTag:pass
class Suburb(xju.newtype.Str[SuburbTag]):pass

class PostcodeTag:pass
class Postcode(xju.newtype.Int[PostcodeTag]):pass

@dataclass
class Address:
    street:Street
    suburb:Suburb
    postcode:Postcode


Assert(Codec[Address](Address).decode({
    'street':'alba',
    'suburb': 'bocca',
    'postcode': 3365}))==Address(Street('alba'),Suburb('bocca'),Postcode(3365))
        
Assert(Codec[Address](Address).encode(Address(Street('alba'),Suburb('bocca'),Postcode(3365))))=={
    'street':'alba',
    'suburb': 'bocca',
    'postcode': 3365}
        
#incorrect Address value type
try:
    x=Codec[Address](Address).decode({'jock': 'fred'})
except Exception as e:
    Assert(str(e)).matches(re.escape("failed to decode {'jock': 'fred'} to a <class '__main__.Address'> because"))
    Assert(str(e)).endswith("{'jock': 'fred'} has no 'street' attribute")
else:
    assert False, x
    pass

try:
    x=Codec[Address](Address).encode(7) # type: ignore
except Exception as e:
    Assert(str(e)).endswith("7 (of type <class 'int'>) is not a <class '__main__.Address'>")
else:
    assert False, x
    pass

bad_postcode=Address(Street('alba'),Suburb('bocca'),3365)  # type: ignore
try:
    x=Codec[Address](Address).encode(bad_postcode)
except Exception as e:
    Assert(str(e)).endswith("3365 is not a <class '__main__.Postcode'>")
else:
    assert False, x
    pass

class UnitTag: pass
class Unit(xju.newtype.Str[UnitTag]):
    pass

@dataclass
class ManagerName:
    a: str
    b: int

# class inheritance...
@dataclass
class UnitAddress(Address,ManagerName):
    unit:Unit

# ... __init__ argument order is assumed to be that used by dataclass, i.e. classes in
# reverse-mro (see python mro() and __mro__) with attributes of each class in usual order, so
# order of UnitAddress __init__ args is
# ManagerName attrs in order (i.e. a, b) then Address attrs in order (i.e. street, suburb, postcode)
# then UnitAddress attributes in order (i.e. unit), so in total:
# a, b, street, suburb, postcode.
# Decode does not care about json dict order...
Assert(Codec[UnitAddress](UnitAddress).decode({
    'street':'alba',
    'suburb': 'bocca',
    'postcode': 3365,
    'unit': '17a',
    'a': 'fred',
    'b': 17}))==UnitAddress('fred',17,Street('alba'),Suburb('bocca'),Postcode(3365),Unit('17a'))

# ... encode will order attrs per description above
Assert(Codec[UnitAddress](UnitAddress).encode(
    UnitAddress('fred',17,Street('alba'),Suburb('bocca'),Postcode(3365),unit=Unit('17a'))))=={
        'a': 'fred',
        'b': 17,
        'street':'alba',
        'suburb': 'bocca',
        'postcode': 3365,
        'unit': '17a'}
Assert(list(cast(dict,Codec[UnitAddress](UnitAddress).encode(
    UnitAddress('fred',17,Street('alba'),Suburb('bocca'),Postcode(3365),unit=Unit('17a')))).keys()))==[
        'a',
        'b',
        'street',
        'suburb',
        'postcode',
        'unit']
        

# string Literal
#mypy 1.0.0 bug:
#Codec[Literal['fred']](Literal['fred'])
# ... says:
#  error: Argument 1 to "Codec" has incompatible type "object"; expected "Type[Literal['fred']]"  [arg-type]

Assert(Codec[Literal['fred']](Literal['fred']).decode('fred'))=='fred' # type: ignore
Assert(Codec[Literal['fred']](Literal['fred']).encode('fred'))=='fred' # type: ignore

#non-string literal not yet implemented
try:
    x=Codec[Literal[7]](Literal[7]).decode(7) # type: ignore
except Exception as e:
    Assert("typing.Literal[7] literal type is not supported (only string is implemented)").isIn(str(e))
else:
    assert False, x
    pass


#encode wrong type
try:
    x=Codec[Literal['fred']](Literal['fred']).encode(7) # type: ignore
except Exception as e:
    Assert("7 is not 'fred'").isIn(str(e))
else:
    assert False, x
    pass
#decode wrong type
try:
    x=Codec[Literal['fred']](Literal['fred']).decode(7) # type: ignore
except Exception as e:
    Assert("7 is not a string").isIn(str(e))
else:
    assert False, x
    pass

# string literal attributes match that string literal...
@dataclass
class Add:
    a:int
    b:int
    op_type: Literal['add'] = 'add'  # note default value is required or get run-time error, see below

Assert(Codec[Add](Add).decode(
    {
        'op_type':'add',
        'a': 7,
        'b': 8
    }))==Add(7,8)
        
Assert(Codec[Add](Add).decode({
    'op_type':'add',
    'a': 7,
    'b': 8}).op_type)=='add'
        
Assert(Codec[Add](Add).encode(Add(7,8))=={
    'op_type':'add',
    'a': 7,
    'b': 8})
        
# ... and rejected other values...
try:
    x=Codec[Add](Add).decode({
        'op_type':'subtract',
        'a': 7,
        'b': 8})
except Exception as e:
    Assert(str(e)).contains("'subtract' is not 'add'")
else:
    assert False, x
    pass

# ... allowing them to be used as type descriminators...
@dataclass
class Sub:
    a:int
    b:int
    op_type: Literal['sub'] = 'sub'

Assert(Codec[Add|Sub](Add|Sub).decode({  # type: ignore
    'op_type':'sub',
    'a': 7,
    'b': 8}))==Sub(7,8)

# ... note they must be given a default value, otherwise...
@dataclass
class MissingDefault:
    op_type: Literal['op']
    sub_type: Literal['plus']
    a:int
    b:int

try:
    x=Codec[MissingDefault](MissingDefault).decode({
        'op_type':'op',
        'sub_type':'plus',
        'a': 7,
        'b': 8})
except Exception as e:
    Assert(readable_repr(e)).contains("failed to init <class '__main__.MissingDefault'> with positional parameters [7, 8] because")
    Assert(readable_repr(e)).contains("MissingDefault.__init__() missing 2 required positional arguments: 'a' and 'b'") # note we're actually missing 'op_type' and 'sub_type', because we forgot to give default values in our class definition
else:
    assert False, x
    pass

# misc coverage
Assert(repr(Codec[int](int)))=="<class 'int'> json codec"


Assert(Codec[int|None](int|None).decode(None))==None # type: ignore
Assert(Codec[int|None](int|None).encode(None))==None # type: ignore

try:
    x=Codec[int|None](int|None).decode('fred')  # type: ignore
except Exception as e:
    Assert(str(e)).contains("'fred' is not None")
else:
    assert False, x
    pass

try:
    x=Codec[int|None](int|None).encode('fred')  # type: ignore
except Exception as e:
    Assert(str(e)).contains("'fred' is not None")
else:
    assert False, x
    pass


# Codec can generate corresponding json schema (http://json-schema.org)
# "null", "boolean", "object", "array", "number", "string", or "integer"
Assert(Codec[None](type(None)).get_json_schema())=={'type': 'null', 'definitions': {}, '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'}
Assert(Codec[int](int).get_json_schema())=={'type': 'integer', 'definitions': {}, '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'}
Assert(Codec[bool](bool).get_json_schema())=={'type': 'boolean', 'definitions': {}, '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'}
Assert(Codec[str](str).get_json_schema())=={'type': 'string', 'definitions': {}, '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'}
Assert(Codec[float](float).get_json_schema())=={'type': 'number', 'definitions': {}, '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'}
Assert(Codec[list](list).get_json_schema())=={'type': 'array', 'definitions': {}, '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'}
Assert(Codec[list[int]](list[int]).get_json_schema())=={'type': 'array', 'items': { 'type': 'integer'}, 'definitions': {}, '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'}
# mypy 1.0.0 + python 3.11 bug:
# Argument 1 to "Codec" has incompatible type "Type[Tuple[Any, ...]]"; expected "Type[Tuple[int, str]]"  [arg-type]
Assert(Codec[tuple[int,str]](tuple[int,str]).get_json_schema())=={'type': 'array', 'prefixItems': [ { 'type': 'integer'},{ 'type': 'string'}], 'definitions': {}, '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'} # type: ignore

# mypy 1.0.0 + python 3.11 bug:
# Argument 1 to "Codec" has incompatible type "<typing special form>"; expected "Union[Type[None], Type[bool], Type[Dict[Any, Any]], Type[List[Any]], Type[float], Type[str]]"  [arg-type]
Assert(Codec[JsonType](JsonType).get_json_schema())=={'oneOf': [{'type': 'null'}, {'type': 'boolean'}, {'type': 'object'}, {'type': 'array'}, {'type': 'number'}, {'type': 'string'}], 'definitions': {}, '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'} # type: ignore

Assert(Codec[dict](dict).get_json_schema())=={'type': 'object', 'definitions': {}, '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'}

Assert(Codec[dict[str,int]](dict[str,int]).get_json_schema())=={'type': 'object', 'additionalProperties': {'type': 'integer'}, 'definitions': {}, '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'}

Assert(AnyJsonCodec().get_json_schema({},None))== {'oneOf': [{'type': 'null'}, {'type': 'boolean'}, {'type': 'object'}, {'type': 'array'}, {'type': 'number'}, {'type': 'string'}]}

Assert(Codec[AgeInYears](AgeInYears).get_json_schema())=={'description': 'AgeInYears', 'type': 'integer', 'definitions': {}, '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'}

Assert(Codec[Street](Street).get_json_schema())=={'description': 'Street', 'type': 'string', 'definitions': {}, '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'}

Assert(Codec[Metres](Metres).get_json_schema())=={'description': 'Metres', 'type': 'number', 'definitions': {}, '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'}

Assert(Codec[Literal['fred']](Literal['fred']).get_json_schema())=={'type': 'string', 'enum': ['fred'], 'definitions': {}, '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'} # type: ignore

Assert(Codec[Address](Address).get_json_schema())=={
    '$ref': '#/definitions/__main__.Address',
    '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema',
    'definitions':{
        '__main__.Address':{
            'description': 'Address',
            'type': 'object',
            'properties': {'street': {'description': 'Street', 'type': 'string'}, 'suburb': {'description': 'Suburb', 'type': 'string'}, 'postcode': {'description': 'Postcode', 'type': 'integer'}}}}}



# recursive via Self
class LeafTag:pass
class Leaf(xju.newtype.Int[LeafTag]):pass

@dataclass
class Branch:
    shoots: list[Leaf|Self]
    pass

Tree = Branch|Leaf

Assert(Codec[Branch](Branch).encode(Branch([Branch([Leaf(1),Leaf(2)]),Leaf(3)])))=={'shoots':[{'shoots':[1,2]},3]}
Assert(Codec[Branch](Branch).decode({'shoots':[{'shoots':[1,2]},3]}))==Branch([Branch([Leaf(1),Leaf(2)]),Leaf(3)])
Assert(Codec[Branch](Branch).get_json_schema())=={
    '$ref': '#/definitions/__main__.Branch',
    '$id': 'https://example.com/address.schema.json',
    '$schema': 'https://json-schema.org/draft/2020-12/schema',
    'definitions': {
        '__main__.Branch': {'description': 'Branch', 'type': 'object', 'properties': {
            'shoots': {'type': 'array', 'items': {'oneOf': [
                {'description': 'Leaf', 'type': 'integer'},
                {'$ref': '#/definitions/__main__.Branch'}]}}}}}}

@dataclass
class Graph:
    value: int
    next: list[Self]
    pass

Assert(Codec[Graph](Graph).encode(
    Graph(1, [Graph(2,[]),Graph(3,[])])))=={
        'value':1,'next':[
            {'value':2, 'next':[]},
            {'value':3, 'next':[]}]}
Assert(Codec[Graph](Graph).get_json_schema())=={
    '$ref': '#/definitions/__main__.Graph',
    '$id': 'https://example.com/address.schema.json',
    '$schema': 'https://json-schema.org/draft/2020-12/schema',
    'definitions': {
        '__main__.Graph': {'description': 'Graph', 'type': 'object', 'properties': {
            'value': {'type': 'integer'},
            'next': {'type': 'array', 'items': {'$ref': '#/definitions/__main__.Graph'}}}}}}

def fail_back_ref_encode(x: Any) -> JsonType:
    raise Exception('back_ref fail')
try:
    SelfCodec().encode(7,fail_back_ref_encode)
except Exception as e:
    Assert(readable_repr(e))=='Failed to encode 7 as a Self because\nback_ref fail.'
else:
    assert False
    pass

def fail_back_ref_decode(x: JsonType) -> Any:
    raise Exception('back_ref fail')
try:
    SelfCodec().decode(7,fail_back_ref_decode)
except Exception as e:
    Assert(readable_repr(e))=='Failed to deocde 7 as a Self because\nback_ref fail.'
else:
    assert False
    pass

try:
    import jsonschema # type: ignore
except:
    print('WARNING: skipped json_codec json_schema tests because json_schema not importable',
          file=sys.stderr)
else:
    jsonschema.validate(None,Codec[None](type(None)).get_json_schema())
    jsonschema.validate(7,Codec[int](int).get_json_schema())
    jsonschema.validate(True,Codec[bool](bool).get_json_schema())
    jsonschema.validate('fred',Codec[str](str).get_json_schema())
    jsonschema.validate(8.8,Codec[float](float).get_json_schema())
    jsonschema.validate([1,True],Codec[list](list).get_json_schema())
    jsonschema.validate([1,2],Codec[list[int]](list[int]).get_json_schema())
    # mypy 1.0.0 + python 3.11 bug:
    # Argument 1 to "Codec" has incompatible type "Type[Tuple[Any, ...]]"; expected "Type[Tuple[int, str]]"  [arg-type]
    jsonschema.validate([7,'fred'],Codec[tuple[int,str]](tuple[int,str]).get_json_schema()) # type:ignore

    # mypy 1.0.0 + python 3.11 bug:
    # Argument 1 to "Codec" has incompatible type "<typing special form>"; expected "Union[Type[None], Type[bool], Type[Dict[Any, Any]], Type[List[Any]], Type[float], Type[str]]"  [arg-type]
    jsonschema.validate(None,Codec[JsonType](JsonType).get_json_schema()) # type: ignore
    jsonschema.validate(True,Codec[JsonType](JsonType).get_json_schema()) # type: ignore
    jsonschema.validate({},Codec[JsonType](JsonType).get_json_schema()) # type: ignore
    jsonschema.validate([],Codec[JsonType](JsonType).get_json_schema()) # type: ignore
    jsonschema.validate(9.9,Codec[JsonType](JsonType).get_json_schema()) # type: ignore
    jsonschema.validate('fred',Codec[JsonType](JsonType).get_json_schema()) # type: ignore

    jsonschema.validate({},Codec[dict](dict).get_json_schema())

    jsonschema.validate({'fred':2, 'jock':3},Codec[dict[str,int]](dict[str,int]).get_json_schema())

    jsonschema.validate(None,AnyJsonCodec().get_json_schema({},None)) # type: ignore
    jsonschema.validate(True,AnyJsonCodec().get_json_schema({},None)) # type: ignore
    jsonschema.validate({},AnyJsonCodec().get_json_schema({},None)) # type: ignore
    jsonschema.validate([],AnyJsonCodec().get_json_schema({},None)) # type: ignore
    jsonschema.validate(9.9,AnyJsonCodec().get_json_schema({},None)) # type: ignore
    jsonschema.validate('fred',AnyJsonCodec().get_json_schema({},None)) # type: ignore

    jsonschema.validate(77,Codec[AgeInYears](AgeInYears).get_json_schema())

    jsonschema.validate('pole',Codec[Street](Street).get_json_schema())

    jsonschema.validate(8.8,Codec[Metres](Metres).get_json_schema())

    jsonschema.validate('fred',Codec[Literal['fred']](Literal['fred']).get_json_schema()) # type: ignore
    jsonschema.validate({
        'street':'alba',
        'suburb': 'bocca',
        'postcode': 3365},Codec[Address](Address).get_json_schema())
    jsonschema.validate(
        {'shoots':[{'shoots':[1,2]},3]},
        Codec[Branch](Branch).get_json_schema())
    jsonschema.validate(
        {'shoots':[{'shoots':[1,2]},3]},
        Codec[Branch](Branch).get_json_schema())
    pass

# internal: codecs' encode()s must verify correct type passed in, otherwise
# UnionCodec encode try-each algorithm is invalid
try:
    x=Codec[int](int).encode('fred') # type: ignore
except Exception as e:
    Assert("'fred' is not a <class 'int'>").isIn(str(e))
else:
    assert False, x
    pass
try:
    x=Codec[list[int]](list[int]).encode('fred') # type: ignore
except Exception as e:
    Assert("'fred' is not a list").isIn(str(e))
else:
    assert False, x
    pass
try:
    x=Codec[list](list).encode('fred') # type: ignore
except Exception as e:
    Assert("'fred' is not a list").isIn(str(e))
else:
    assert False, x
    pass
try:
    x=Codec[tuple[int]](tuple[int]).encode('fred') # type: ignore
except Exception as e:
    Assert("'fred' is not a tuple").isIn(str(e))
else:
    assert False, x
    pass


# ensure JsonType (Union) selects correct codec to encode dict
@dataclass
class Y:
    x: JsonType
    pass

Assert(Codec[Y](Y).encode(Y({ 'z': 'fred' })))=={'x':{'z':'fred'}}
Assert(Codec[Y](Y).decode({'x':{'z':'fred'}}))==Y({ 'z': 'fred' })
Assert(Codec[Y](Y).get_json_schema())=={
    '$ref': '#/definitions/__main__.Y',
    '$id': 'https://example.com/address.schema.json',
    '$schema': 'https://json-schema.org/draft/2020-12/schema',
    'definitions': {
        '__main__.Y': {
            'description': 'Y', 'type': 'object', 'properties': {
                'x': {
                    'oneOf': [
                        {'type': 'null'},
                        {'type': 'boolean'},
                        {'type': 'object'},
                        {'type': 'array'},
                        {'type': 'number'},
                        {'type': 'string'}]}}}}}


# type hint string are supported, allowing forward-decls
@dataclass
class ShirtSize:
    size: 'SizeCode'
    pass

Small=Literal['S']
Large=Literal['L']
SizeCode=Small|Large

Assert(Codec[ShirtSize](ShirtSize).decode(
    {
        'size': 'S',
    }
))==ShirtSize('S')
