#!/usr/bin/env python3

from xju.json_codec import Codec, JsonType, AnyJsonCodec

from typing import cast, Type, Literal, Any
from types import NoneType
from dataclasses import dataclass
import re

from xju.assert_ import Assert
import xju.newtype

x:Any


# int,str,bool,float,None map directly

Assert(Codec[int](int).decode(3))==3
Assert(Codec[str](str).decode('fred'))=='fred'
Assert(Codec[bool](bool).decode(True))==True
Assert(Codec[float](float).decode(5.5))==5.5
Assert(Codec[float](float).decode(5))==5

Assert(Codec[int](int).encode(3))==3
Assert(Codec[str](str).encode('fred'))=='fred'
Assert(Codec[bool](bool).encode(True))==True
Assert(Codec[float](float).encode(5.5))==5.5
Assert(Codec[float](float).encode(5))==5.0

# note None is a bit weird, sometimes it acts as as a type, others not
Assert(Codec[None](type(None)).decode(None))==None
Assert(Codec[None](type(None)).encode(None))==None


# list maps to list...
Assert(Codec[list](list).decode([5, 'fred']))==[5, 'fred']
Assert(Codec[list](list).encode([5, 'fred']))==[5, 'fred']

# ... but must be given a list
try:
    x=Codec[list](list).decode(8)
except Exception as e:
    Assert("8 is not a list").isIn(str(e))
else:
    assert False, x
    pass
# ... note element types are not checked (it is assumed
# result will be given to json.dumps, which will fail), e.g.
# we can happily put print, which has no mapping to a json type,
# into a non-type-adorned list and encode that list:
Assert(Codec[list](list).encode([print]))==[print]


# type-adorned list maps to list...
Assert(Codec[list[int]](list[int]).decode([5, 6]))==[5, 6]
Assert(Codec[list[int]](list[int]).encode([5, 6]))==[5, 6]

# ... but must be given a list...
try:
    x=Codec[list[int]](list[int]).decode(8)
except Exception as e:
    Assert("8 is not a list").isIn(str(e))
else:
    assert False, x
    pass

# ... and all values must have correct type
try:        
    x=Codec[list[int]](list[int]).decode([5, 'fred'])
except Exception as e:
    Assert("'fred' (of type <class 'str'>) is not a <class 'int'>").isIn(str(e))
else:
    assert False, x
    pass


# tuple encodes as list (note, tuples without specific element types are disallowed)

#mypy 1.0.0 bug:
#c=Codec[tuple[int,str]](tuple[int,str])
# ... says:
# /home/xju/urnest/xju/json_codec.py.test:43: error: Argument 1 to "Codec" has incompatible type "Type[Tuple[Any, ...]]"; expected "Type[Tuple[int, str]]"  [arg-type]
# ... but there are so many tuple-related bugs on github it's not really surprising

tuple_codec=Codec[tuple[int,str]](cast(Type[tuple[int,str]],tuple[int,str]))  #mypy 1.0.0 bug
Assert(tuple_codec.decode([5, 'fred']))==(5, 'fred')
Assert(tuple_codec.encode((5, 'fred')))==[5, 'fred']

# for list to decode as tuple, it must be a list in the first place...
try:        
    x=tuple_codec.decode({'x':6, 'y':8})
except Exception as e:
    Assert("{'x': 6, 'y': 8} is not a list").isIn(str(e))
else:
    assert False, x
    pass

# ... it must have expected number of elements each of the expected type...
try:        
    x=tuple_codec.decode([5, 6, 7])
except Exception as e:
    Assert("[5, 6, 7] does not have 2 items (it has 3 items)").isIn(str(e))
else:
    assert False, x
    pass

# ... each element must have correct type...
try:
    x=tuple_codec.decode([5, 6])
except Exception as e:
    Assert("6 (of type <class 'int'>) is not a <class 'str'>").isIn(str(e))
else:
    assert False, x
    pass

# encoding also rejects wrong number of elements, but this would be
# rejected by type checker anyway
try:
    x=tuple_codec.encode((5, 6, 7))  # type: ignore
except Exception as e:
    Assert("(5, 6, 7) does not have 2 items (it has 3 items)").isIn(str(e))
else:
    assert False, x
    pass


# dict with no type hints allows any keys with any value types (key must be string)
Assert(Codec[dict](dict).decode({'fred':5, 'jock': 'nine'}))=={'fred':5, 'jock':'nine'}
Assert(Codec[dict](dict).encode({'fred':5, 'jock': 'nine'}))=={'fred':5, 'jock':'nine'}

# dict with specific value type...
Assert(Codec[dict[str,int]](dict[str,int]).decode({'fred':5, 'jock': 9}))=={'fred':5, 'jock':9}
Assert(Codec[dict[str,int]](dict[str,int]).encode({'fred':5, 'jock': 9}))=={'fred':5, 'jock':9}

# ... must be given a dict...
try:
    x=Codec[dict](dict).decode(7)
except Exception as e:
    Assert("7 is not a dict").isIn(str(e))
else:
    assert False, x
    pass
try:
    x=Codec[dict[str,int]](dict[str,int]).decode(7)
except Exception as e:
    Assert("7 is not a dict").isIn(str(e))
else:
    assert False, x
    pass

# ... expects all elements to have that value type incorrect dict value type
try:
    x=Codec[dict[str,int]](dict[str,int]).decode({'jock': 'fred'})
except Exception as e:
    Assert("'fred' (of type <class 'str'>) is not a <class 'int'>").isIn(str(e))
else:
    assert False, x
    pass

# dict keys must be strings...
try:
    x=Codec[dict](dict).encode({6: 'fred'})
except Exception as e:
    Assert(str(e)).matches("6 is not a <class 'str'>")
else:
    assert False, x
    pass
try:
    x=Codec[dict[int,int]](dict[int,int]).encode({7:5}) # type: ignore
except Exception as e:
    Assert("produced non-str 7 from dict key 7").isIn(str(e))
else:
    assert False, x
    pass

# ... must be given a dict...
try:
    x=Codec[dict](dict).encode(7) # type: ignore
except Exception as e:
    Assert("7 is not a dict").isIn(str(e))
else:
    assert False, x
    pass
try:
    x=Codec[dict[str,int]](dict[str,int]).encode(7) # type: ignore
except Exception as e:
    Assert("7 is not a dict").isIn(str(e))
else:
    assert False, x
    pass

#xju.newtype.Int support
class AgeInYearsTag:pass
class AgeInYears(xju.newtype.Int[AgeInYearsTag]):pass

Assert(Codec[AgeInYears](AgeInYears).decode(3))==AgeInYears(3)
Assert(Codec[AgeInYears](AgeInYears).encode(AgeInYears(3)))==3

try:
    x=Codec[AgeInYears](AgeInYears).decode('fred')
except Exception as e:
    Assert("'fred' (of type <class 'str'>) is not an int").isIn(str(e))
else:
    assert False, x
    pass

try:        
    x=Codec[AgeInYears](AgeInYears).encode(8) # type: ignore
except Exception as e:
    Assert("8 is not a <class '__main__.AgeInYears'>").isIn(str(e))
else:
    assert False, x
    pass

#xju.newtype.Float support
class MetresTag:pass
class Metres(xju.newtype.Float[MetresTag]):pass

Assert(Codec[Metres](Metres).decode(3.8))==Metres(3.8)
Assert(Codec[Metres](Metres).encode(Metres(3.8)))==3.8
Assert(Codec[Metres](Metres).decode(3))==Metres(3)
Assert(Codec[Metres](Metres).encode(Metres(3)))==3

try:
    x=Codec[Metres](Metres).decode('fred')
except Exception as e:
    Assert("'fred' (of type <class 'str'>) is not a float (or an int)").isIn(str(e))
else:
    assert False, x
    pass

try:
    x=Codec[Metres](Metres).encode('fred') # type: ignore
except Exception as e:
    Assert("'fred' is not a <class '__main__.Metres'>").isIn(str(e))
else:
    assert False, x
    pass

#xju.newtype.Str support
class SurnameTag:pass
class Surname(xju.newtype.Str[SurnameTag]):pass

Assert(Codec[Surname](Surname).decode('Ang'))==Surname('Ang')
Assert(Codec[Surname](Surname).encode(Surname('Ang')))=='Ang'

try:
    x=Codec[Surname](Surname).decode(17)
except Exception as e:
    Assert("17 (of type <class 'int'>) is not an str").isIn(str(e))
else:
    assert False, x
    pass

try:
    x=Codec[Surname](Surname).encode(17) # type: ignore
except Exception as e:
    Assert("17 is not a <class '__main__.Surname'>").isIn(str(e))
else:
    assert False, x
    pass


#mypy 1.0.0 bug
#union_codec=Codec[str|int](str|int)
# says:
#  error: Argument 1 to "Codec" has incompatible type "UnionType"; expected "Union[Type[str], Type[int]]"  [arg-type]

union_codec=Codec[str|int](cast(Type[str|int],str|int))
Assert(union_codec.decode('fred'))=='fred'
Assert(union_codec.decode(9))==9
Assert(union_codec.encode('fred'))=='fred'
Assert(union_codec.encode(9))==9

#incorrect dict value type
try:
    x=union_codec.decode(5.7)
except Exception as e:
    Assert(str(e)).matches("failed to decode 5.7 to a str | int because.*failed to decode as <class 'str'> because 5.7 (of type <class 'float'>) is not a <class 'str'> and failed to decode as <class 'int'> because 5.7 (of type <class 'float'>) is not a <class 'int'>")
else:
    assert False, x
    pass


class StreetTag:pass
class Street(xju.newtype.Str[StreetTag]):pass

class SuburbTag:pass
class Suburb(xju.newtype.Str[SuburbTag]):pass

class PostcodeTag:pass
class Postcode(xju.newtype.Int[PostcodeTag]):pass

@dataclass
class Address:
    street:Street
    suburb:Suburb
    postcode:Postcode


Assert(Codec[Address](Address).decode({
    'street':'alba',
    'suburb': 'bocca',
    'postcode': 3365}))==Address(Street('alba'),Suburb('bocca'),Postcode(3365))
        
Assert(Codec[Address](Address).encode(Address(Street('alba'),Suburb('bocca'),Postcode(3365))))=={
    'street':'alba',
    'suburb': 'bocca',
    'postcode': 3365}
        
#incorrect Address value type
try:
    x=Codec[Address](Address).decode({'jock': 'fred'})
except Exception as e:
    Assert(str(e)).matches(re.escape("failed to decode {'jock': 'fred'} to a <class '__main__.Address'> because"))
    Assert(str(e)).endswith("{'jock': 'fred'} has no 'street' attribute")
else:
    assert False, x
    pass

try:
    x=Codec[Address](Address).encode(7) # type: ignore
except Exception as e:
    Assert(str(e)).endswith("7 (of type <class 'int'>) is not a <class '__main__.Address'>")
else:
    assert False, x
    pass

bad_postcode=Address(Street('alba'),Suburb('bocca'),3365)  # type: ignore
try:
    x=Codec[Address](Address).encode(bad_postcode)
except Exception as e:
    Assert(str(e)).endswith("3365 is not a <class '__main__.Postcode'>")
else:
    assert False, x
    pass


#mypy 1.0.0 bug:
#Codec[Literal['fred']](Literal['fred'])
# ... says:
#  error: Argument 1 to "Codec" has incompatible type "object"; expected "Type[Literal['fred']]"  [arg-type]

Assert(Codec[Literal['fred']](Literal['fred']).decode('fred'))=='fred' # type: ignore
Assert(Codec[Literal['fred']](Literal['fred']).encode('fred'))=='fred' # type: ignore

#non-string literal not yet implemented
try:
    x=Codec[Literal[7]](Literal[7]).decode(7) # type: ignore
except Exception as e:
    Assert("typing.Literal[7] literal type is not implemented (only string is implemented)").isIn(str(e))
else:
    assert False, x
    pass


#encode wrong type
try:
    x=Codec[Literal['fred']](Literal['fred']).encode(7) # type: ignore
except Exception as e:
    Assert("7 is not 'fred'").isIn(str(e))
else:
    assert False, x
    pass
#decode wrong type
try:
    x=Codec[Literal['fred']](Literal['fred']).decode(7) # type: ignore
except Exception as e:
    Assert("7 is not a string").isIn(str(e))
else:
    assert False, x
    pass


@dataclass
class Add:
    a:int
    b:int
    op_type: Literal['add'] = 'add'

Assert(Codec[Add](Add).decode({
    'op_type':'add',
    'a': 7,
    'b': 8}))==Add(7,8)
        
Assert(Codec[Add](Add).decode({
    'op_type':'add',
    'a': 7,
    'b': 8}).op_type)=='add'
        
Assert(Codec[Add](Add).encode(Add(7,8))=={
    'op_type':'add',
    'a': 7,
    'b': 8})
        
#incorrect value type
try:
    x=Codec[Add](Add).decode({
        'op_type':'subtract',
        'a': 7,
        'b': 8})
except Exception as e:
    Assert(str(e)).contains("'subtract' is not 'add'")
else:
    assert False, x
    pass


@dataclass
class Sub:
    a:int
    b:int
    op_type: Literal['sub'] = 'sub'

Assert(Codec[Add|Sub](Add|Sub).decode({  # type: ignore
    'op_type':'sub',
    'a': 7,
    'b': 8}))==Sub(7,8)


# misc coverage
Assert(repr(Codec[int](int)))=="<class 'int'> json codec"


Assert(Codec[int|None](int|None).decode(None))==None # type: ignore
Assert(Codec[int|None](int|None).encode(None))==None # type: ignore

try:
    x=Codec[int|None](int|None).decode('fred')  # type: ignore
except Exception as e:
    Assert(str(e)).contains("'fred' is not None")
else:
    assert False, x
    pass

try:
    x=Codec[int|None](int|None).encode('fred')  # type: ignore
except Exception as e:
    Assert(str(e)).contains("'fred' is not None")
else:
    assert False, x
    pass


# Codec can generate corresponding json schema (http://json-schema.org)
# "null", "boolean", "object", "array", "number", "string", or "integer"
Assert(Codec[None](type(None)).get_json_schema())=={'type': 'null', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'}
Assert(Codec[int](int).get_json_schema())=={'type': 'integer', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'}
Assert(Codec[bool](bool).get_json_schema())=={'type': 'boolean', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'}
Assert(Codec[str](str).get_json_schema())=={'type': 'string', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'}
Assert(Codec[float](float).get_json_schema())=={'type': 'number', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'}
Assert(Codec[list](list).get_json_schema())=={'type': 'array', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'}
Assert(Codec[list[int]](list[int]).get_json_schema())=={'type': 'array', 'items': { 'type': 'integer'}, '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'}
# mypy 1.0.0 + python 3.11 bug:
# Argument 1 to "Codec" has incompatible type "Type[Tuple[Any, ...]]"; expected "Type[Tuple[int, str]]"  [arg-type]
Assert(Codec[tuple[int,str]](tuple[int,str]).get_json_schema())=={'type': 'array', 'prefixItems': [ { 'type': 'integer'},{ 'type': 'string'}], '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'} # type: ignore

# mypy 1.0.0 + python 3.11 bug:
# Argument 1 to "Codec" has incompatible type "<typing special form>"; expected "Union[Type[None], Type[bool], Type[Dict[Any, Any]], Type[List[Any]], Type[float], Type[str]]"  [arg-type]
Assert(Codec[JsonType](JsonType).get_json_schema())=={'oneOf': [{'type': 'null'}, {'type': 'boolean'}, {'type': 'object'}, {'type': 'array'}, {'type': 'number'}, {'type': 'string'}], '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'} # type: ignore

Assert(Codec[dict](dict).get_json_schema())=={'type': 'object', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'}

Assert(Codec[dict[str,int]](dict[str,int]).get_json_schema())=={'type': 'object', 'additionalProperties': {'type': 'integer'}, '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'}

Assert(AnyJsonCodec().get_json_schema())== {'oneOf': [{'type': 'null'}, {'type': 'boolean'}, {'type': 'object'}, {'type': 'array'}, {'type': 'number'}, {'type': 'string'}]}

Assert(Codec[AgeInYears](AgeInYears).get_json_schema())=={'description': 'AgeInYears', 'type': 'integer', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'}

Assert(Codec[Street](Street).get_json_schema())=={'description': 'Street', 'type': 'string', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'}

Assert(Codec[Metres](Metres).get_json_schema())=={'description': 'Metres', 'type': 'number', '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'}

Assert(Codec[Literal['fred']](Literal['fred']).get_json_schema())=={'type': 'string', 'enum': ['fred'], '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'} # type: ignore

# codecs' encode()s must verify correct type passed in, otherwise
# UnionCodec encode try-each algorithm is invalid
try:
    x=Codec[int](int).encode('fred') # type: ignore
except Exception as e:
    Assert("'fred' is not a <class 'int'>").isIn(str(e))
else:
    assert False, x
    pass
try:
    x=Codec[list[int]](list[int]).encode('fred') # type: ignore
except Exception as e:
    Assert("'fred' is not a list").isIn(str(e))
else:
    assert False, x
    pass
try:
    x=Codec[list](list).encode('fred') # type: ignore
except Exception as e:
    Assert("'fred' is not a list").isIn(str(e))
else:
    assert False, x
    pass
try:
    x=Codec[tuple[int]](tuple[int]).encode('fred') # type: ignore
except Exception as e:
    Assert("'fred' is not a tuple").isIn(str(e))
else:
    assert False, x
    pass


# random test case to ensure JsonType (Union) selects correct codec to encode dict
@dataclass
class Y:
    x: JsonType
    pass

Assert(Codec[Y](Y).encode(Y({ 'z': 'fred' })))=={'x':{'z':'fred'}}
Assert(Codec[Y](Y).get_json_schema())=={'description': 'Y', 'type': 'object', 'properties': {'x': {'oneOf': [{'type': 'null'}, {'type': 'boolean'}, {'type': 'object'}, {'type': 'array'}, {'type': 'number'}, {'type': 'string'}]}}, '$id': 'https://example.com/address.schema.json', '$schema': 'https://json-schema.org/draft/2020-12/schema'}
